     1                                  %include "../includes/startup.inc"
     2                              <1> %ifndef _ASM_BOOTCD_INC_
     3                              <1>      %define   _ASM_BOOTCD_INC_ 1
     4                              <1> 
     5                              <1>      %define   KERNELSTARTCS   0x0070   ; we load the kernel at 0070:0000 the I/O drivers from IO.SYS and IBMBIO.COM
     6                              <1>      %define   KERNELSTARTIP   0x0000   ; this gives us 0070:0000 - 07C0:0000 memory to use for kernel.bin
     7                              <1>      %define   PEMCS           0x3000
     8                              <1>      %define   PEMIP           0x0000
     9                              <1>      %define   PEMSS           0x7000
    10                              <1>      %define   PEMSP           0xFFFE
    11                              <1>      
    12                              <1> STRUC SPECIFICATION_PACKET_STRUC
    13 00000000 ??                  <1>      .packed_size:                 resb      1
    14 00000001 ??                  <1>      .boot_media_type:             resb      1
    15 00000002 ??                  <1>      .drive_number:                resb      1
    16 00000003 ??                  <1>      .controller_index:            resb      1
    17 00000004 ????????            <1>      .logical_block_address:       resd      1
    18 00000008 ????                <1>      .device_specification:        resw      1
    19 0000000A ????                <1>      .buffer_segment:              resw      1
    20 0000000C ????                <1>      .load_segment:                resw      1
    21 0000000E ????                <1>      .virtual_sectors:             resw      1
    22 00000010 ??                  <1>      .cylinder_count:              resb      1
    23 00000011 ??                  <1>      .sector_count:                resb      1
    24 00000012 ??                  <1>      .head_count:                  resb      1
    25                              <1> ENDSTRUC
    26                              <1> 
    27                              <1> %macro SPECIFICATION_PACKET 1
    28                              <1>      %1:  ISTRUC SPECIFICATION_PACKET_STRUC
    29                              <1>           at   SPECIFICATION_PACKET_STRUC.packed_size,                 db        0x13
    30                              <1>           at   SPECIFICATION_PACKET_STRUC.boot_media_type,             db        0
    31                              <1>           at   SPECIFICATION_PACKET_STRUC.drive_number,                db        0
    32                              <1>           at   SPECIFICATION_PACKET_STRUC.controller_index,            db        0
    33                              <1>           at   SPECIFICATION_PACKET_STRUC.logical_block_address,       dd        0
    34                              <1>           at   SPECIFICATION_PACKET_STRUC.device_specification,        dw        0
    35                              <1>           at   SPECIFICATION_PACKET_STRUC.buffer_segment,              dw        0
    36                              <1>           at   SPECIFICATION_PACKET_STRUC.load_segment,                dw        0
    37                              <1>           at   SPECIFICATION_PACKET_STRUC.virtual_sectors,             dw        0
    38                              <1>           at   SPECIFICATION_PACKET_STRUC.cylinder_count,              db        0
    39                              <1>           at   SPECIFICATION_PACKET_STRUC.sector_count,                db        0
    40                              <1>           at   SPECIFICATION_PACKET_STRUC.head_count,                  db        0
    41                              <1>      IEND
    42                              <1>      %define %1.packed_size                 %1+SPECIFICATION_PACKET_STRUC.packed_size
    43                              <1>      %define %1.boot_media_type             %1+SPECIFICATION_PACKET_STRUC.boot_media_type
    44                              <1>      %define %1.drive_number                %1+SPECIFICATION_PACKET_STRUC.drive_number
    45                              <1>      %define %1.controller_index            %1+SPECIFICATION_PACKET_STRUC.controller_index
    46                              <1>      %define %1.logical_block_address       %1+SPECIFICATION_PACKET_STRUC.logical_block_address
    47                              <1>      %define %1.device_specification        %1+SPECIFICATION_PACKET_STRUC.device_specification
    48                              <1>      %define %1.buffer_segment              %1+SPECIFICATION_PACKET_STRUC.buffer_segment
    49                              <1>      %define %1.load_segment                %1+SPECIFICATION_PACKET_STRUC.load_segment
    50                              <1>      %define %1.virtual_sectors             %1+SPECIFICATION_PACKET_STRUC.virtual_sectors
    51                              <1>      %define %1.cylinder_count              %1+SPECIFICATION_PACKET_STRUC.cylinder_count
    52                              <1>      %define %1.sector_count                %1+SPECIFICATION_PACKET_STRUC.sector_count
    53                              <1>      %define %1.head_count                  %1+SPECIFICATION_PACKET_STRUC.head_count
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> STRUC DISK_ADDRESS_PACKET_STRUC
    57 00000000 ??                  <1>      .size:                        resb      1
    58 00000001 ??                  <1>      .reserved:                    resb      1
    59 00000002 ????                <1>      .sectors_to_read:             resw      1
    60 00000004 ????                <1>      .offset:                      resw      1
    61 00000006 ????                <1>      .segment:                     resw      1
    62 00000008 ????????            <1>      .start_absolute_sector:       resd      1
    63 0000000C ????????            <1>      .transfer_buffer_address:     resd      1
    64                              <1> ENDSTRUC
    65                              <1> 
    66                              <1> %macro DISK_ADDRESS_PACKET 3
    67                              <1>      %1:  ISTRUC DISK_ADDRESS_PACKET_STRUC
    68                              <1>           at   DISK_ADDRESS_PACKET_STRUC.size,                        db        16
    69                              <1>           at   DISK_ADDRESS_PACKET_STRUC.reserved,                    db        0
    70                              <1>           at   DISK_ADDRESS_PACKET_STRUC.sectors_to_read,             dw        1
    71                              <1>           at   DISK_ADDRESS_PACKET_STRUC.offset,                      dw        %3
    72                              <1>           at   DISK_ADDRESS_PACKET_STRUC.segment,                     dw        %2
    73                              <1>           at   DISK_ADDRESS_PACKET_STRUC.start_absolute_sector,       dd        16
    74                              <1>           at   DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address,     dd        0
    75                              <1>      IEND
    76                              <1>      %define %1.size                         %1+DISK_ADDRESS_PACKET_STRUC.size
    77                              <1>      %define %1.sectors_to_read              %1+DISK_ADDRESS_PACKET_STRUC.sectors_to_read
    78                              <1>      %define %1.offset                       %1+DISK_ADDRESS_PACKET_STRUC.offset
    79                              <1>      %define %1.segment                      %1+DISK_ADDRESS_PACKET_STRUC.segment
    80                              <1>      %define %1.start_absolute_sector        %1+DISK_ADDRESS_PACKET_STRUC.start_absolute_sector
    81                              <1>      %define %1.transfer_buffer_address      %1+DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %endif
     2                                  
     3                                  org 0x7C00
     4                                  bits 16
     5                                  
     6                                  global start
     7                                  
     8                                  start:
     9                                  
    10 00000000 EA[5B01]0000                 jmp     0x0000:flushCS                 ;force system to run from cs:ip = 0000:7C00 instead of 07C0:0000
    11                                       
    12 00000005 00                           bootdrive:               db 0
    13 00000006 507265737320616E79-          pressAnyKey:             db 'Press any key to reboot...',13,10,0
    13 0000000F 206B657920746F2072-
    13 00000018 65626F6F742E2E2E0D-
    13 00000021 0A00               
    14 00000023 4B45524E454C2E4249-          fileName:                db 'KERNEL.BIN',0
    14 0000002C 4E00               
    15 0000002E 00                           directoryEntrySize:      db   0
    16 0000002F 00000000                     fileSector:              dd   0
    17 00000033 00000000                     fileSize:                dd   0
    18 00000037 00                           fileNameLength:          db   0
    19 00000038 20<rep FFh>                  fileNameEntry:           TIMES 255 db ' '     
    20 00000137 00                           fileEntryNumber:         db   0     
    21                                       SPECIFICATION_PACKET     specificationPacket
    28                              <1>  %1: ISTRUC SPECIFICATION_PACKET_STRUC
    29 00000138 13                  <1>  at SPECIFICATION_PACKET_STRUC.packed_size, db 0x13
    30 00000139 00                  <1>  at SPECIFICATION_PACKET_STRUC.boot_media_type, db 0
    31 0000013A 00                  <1>  at SPECIFICATION_PACKET_STRUC.drive_number, db 0
    32 0000013B 00                  <1>  at SPECIFICATION_PACKET_STRUC.controller_index, db 0
    33 0000013C 00000000            <1>  at SPECIFICATION_PACKET_STRUC.logical_block_address, dd 0
    34 00000140 0000                <1>  at SPECIFICATION_PACKET_STRUC.device_specification, dw 0
    35 00000142 0000                <1>  at SPECIFICATION_PACKET_STRUC.buffer_segment, dw 0
    36 00000144 0000                <1>  at SPECIFICATION_PACKET_STRUC.load_segment, dw 0
    37 00000146 0000                <1>  at SPECIFICATION_PACKET_STRUC.virtual_sectors, dw 0
    38 00000148 00                  <1>  at SPECIFICATION_PACKET_STRUC.cylinder_count, db 0
    39 00000149 00                  <1>  at SPECIFICATION_PACKET_STRUC.sector_count, db 0
    40 0000014A 00                  <1>  at SPECIFICATION_PACKET_STRUC.head_count, db 0
    41                              <1>  IEND
    42                              <1>  %define %1.packed_size %1+SPECIFICATION_PACKET_STRUC.packed_size
    43                              <1>  %define %1.boot_media_type %1+SPECIFICATION_PACKET_STRUC.boot_media_type
    44                              <1>  %define %1.drive_number %1+SPECIFICATION_PACKET_STRUC.drive_number
    45                              <1>  %define %1.controller_index %1+SPECIFICATION_PACKET_STRUC.controller_index
    46                              <1>  %define %1.logical_block_address %1+SPECIFICATION_PACKET_STRUC.logical_block_address
    47                              <1>  %define %1.device_specification %1+SPECIFICATION_PACKET_STRUC.device_specification
    48                              <1>  %define %1.buffer_segment %1+SPECIFICATION_PACKET_STRUC.buffer_segment
    49                              <1>  %define %1.load_segment %1+SPECIFICATION_PACKET_STRUC.load_segment
    50                              <1>  %define %1.virtual_sectors %1+SPECIFICATION_PACKET_STRUC.virtual_sectors
    51                              <1>  %define %1.cylinder_count %1+SPECIFICATION_PACKET_STRUC.cylinder_count
    52                              <1>  %define %1.sector_count %1+SPECIFICATION_PACKET_STRUC.sector_count
    53                              <1>  %define %1.head_count %1+SPECIFICATION_PACKET_STRUC.head_count
    22                                       DISK_ADDRESS_PACKET      diskAddressPacket,KERNELSTARTCS,KERNELSTARTIP
    67                              <1>  %1: ISTRUC DISK_ADDRESS_PACKET_STRUC
    68 0000014B 10                  <1>  at DISK_ADDRESS_PACKET_STRUC.size, db 16
    69 0000014C 00                  <1>  at DISK_ADDRESS_PACKET_STRUC.reserved, db 0
    70 0000014D 0100                <1>  at DISK_ADDRESS_PACKET_STRUC.sectors_to_read, dw 1
    71 0000014F 0000                <1>  at DISK_ADDRESS_PACKET_STRUC.offset, dw %3
    72 00000151 7000                <1>  at DISK_ADDRESS_PACKET_STRUC.segment, dw %2
    73 00000153 10000000            <1>  at DISK_ADDRESS_PACKET_STRUC.start_absolute_sector, dd 16
    74 00000157 00000000            <1>  at DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address, dd 0
    75                              <1>  IEND
    76                              <1>  %define %1.size %1+DISK_ADDRESS_PACKET_STRUC.size
    77                              <1>  %define %1.sectors_to_read %1+DISK_ADDRESS_PACKET_STRUC.sectors_to_read
    78                              <1>  %define %1.offset %1+DISK_ADDRESS_PACKET_STRUC.offset
    79                              <1>  %define %1.segment %1+DISK_ADDRESS_PACKET_STRUC.segment
    80                              <1>  %define %1.start_absolute_sector %1+DISK_ADDRESS_PACKET_STRUC.start_absolute_sector
    81                              <1>  %define %1.transfer_buffer_address %1+DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address
    23                                               
    24                                  flushCS:
    25                                       ;set segment registers same as codesegment
    26 0000015B FA                           cli                                                              ;turn off intterrupts
    27 0000015C 8CC8                         mov       ax, cs                                                 ;boot Segment
    28 0000015E 8ED8                         mov       ds, ax
    29 00000160 8EC0                         mov       es, ax
    30 00000162 8ED0                         mov       ss, ax
    31 00000164 BCFFFF                       mov       sp, 0xFFFF                                             ;set stackpointer at end of current segment
    32 00000167 FB                           sti                                                              ;turn on interrupts
    33 00000168 8816[0500]                   mov       byte[bootdrive], dl                                    ;save boot drive
    34 0000016C 20D2                         and       dl, dl
    35 0000016E 744B                         jz        notbootable                                            ;if result is zero then failure
    36                                       ;Call Check Extensions Present?
    37 00000170 8A16[0500]                   mov       dl, byte[bootdrive]                                    ;prepare to read CD-ROM, load boot drive
    38 00000174 B441                         mov       ah, 0x41
    39 00000176 BBAA55                       mov       bx, 0x55AA                                             ;signature?
    40 00000179 CD13                         int       0x13                                         
    41 0000017B 723E                         jc        notbootable                                            ;disk is not bootable
    42                                       ;get status: 
    43 0000017D 8A16[0500]                   mov       dl, byte[bootdrive]                                    ;prepare to read CD-ROM, load boot drive
    44 00000181 B8014B                       mov       ax, 0x4B01
    45 00000184 BE[3801]                     mov       si, specificationPacket               
    46 00000187 CD13                         int       0x13
    47                                       ;DL still holds the bootdrive
    48 00000189 2216[3A01]                   and       dl, byte[specificationPacket.drive_number]            ;Load resultant drive information
    49 0000018D 742C                         jz        notbootable                                           ;if result not zero then failure
    50 0000018F 8A16[0500]                   mov       dl, byte[bootdrive]                                   ;Set it up again
    51 00000193 B442                         mov       ah, 0x42                                              ;read from drive function
    52 00000195 BE[4B01]                     mov       si, diskAddressPacket                                 ;load SI with address of the Disk Address Packet
    53 00000198 CD13                         int       0x13                                                  ;call read sector from drive
    54 0000019A 721F                         jc        notbootable
    55 0000019C 8E06[5101]                   mov       es, word[diskAddressPacket.segment]
    56 000001A0 8B3E[4F01]                   mov       di, word[diskAddressPacket.offset]
    57 000001A4 26668B859E00                 mov       eax, dword[es:di+158]                                 ;LBA of root directory, where all things start.
    58 000001AA 66A3[5301]                   mov       dword[diskAddressPacket.start_absolute_sector], eax   ;load packet with new address on CD of the root directory
    59 000001AE 8A16[0500]                   mov       dl, byte[bootdrive]                                   ;set it up again
    60 000001B2 B442                         mov       ah, 0x42                                              ;read from drive function
    61 000001B4 BE[4B01]                     mov       si, diskAddressPacket                                 ;load SI with address of DAP
    62 000001B7 CD13                         int       0x13
    63 000001B9 7318                         jnc       searchbootfile
    64                                  notbootable:
    65 000001BB BE[0600]                     mov       si, pressAnyKey
    66                                       ;print message
    67 000001BE FC                           cld
    68                                  .nextbyte:
    69 000001BF AC                           lodsb                                                           ;Load SI into AL, increment SI one byte
    70 000001C0 20C0                         and       al, al
    71 000001C2 7506                         jnz       .printbyte
    72 000001C4 30E4                         xor       ah, ah
    73 000001C6 CD16                         int       0x16                                                  ;wait for key press
    74 000001C8 CD19                         int       0x19                                                  ;reboot system
    75                                  .printbyte:     
    76 000001CA B40E                         mov       ah, 0x0E
    77 000001CC BB0700                       mov       bx, 0x0007
    78 000001CF CD10                         int       0x10                                                  ;display character in AL
    79 000001D1 EBEC                         jmp       .nextbyte                                             ;repeat for next byte
    80                                  searchbootfile:     
    81                                  .nextdirentry:
    82 000001D3 268A05                       mov       al, byte[es:di]                                       ;length of the current directory entry
    83 000001D6 A2[2E00]                     mov       byte[directoryEntrySize],al
    84 000001D9 26668B4502                   mov       eax, dword[es:di+2]                                   ;starting sector of directory entry
    85 000001DE 66A3[2F00]                   mov       dword[fileSector], eax
    86 000001E2 26668B450A                   mov       eax, dword[es:di+10]                                  ;size of file on CD/DVD/BD
    87 000001E7 66A3[3300]                   mov       dword[fileSize], eax
    88 000001EB 268A4520                     mov       al, byte[es:di+32]                                    ;file's name length (see El Torito of ISO:9660 or CDROM.ASM)
    89 000001EF FEC8                         dec       al                                                    ;for trailing ;
    90 000001F1 FEC8                         dec       al                                                    ;for trailing 1
    91 000001F3 A2[3700]                     mov       byte[fileNameLength], al
    92 000001F6 31DB                         xor       bx, bx
    93 000001F8 31C9                         xor       cx, cx
    94 000001FA 89FE                         mov       si, di
    95 000001FC 83C621                       add       si, 33
    96 000001FF BB[3800]                     mov       bx, fileNameEntry
    97 00000202 A0[3700]                     mov       al, byte[fileNameLength]
    98                                  .LoopFileNameEntry:
    99 00000205 268A04                       mov       al, byte[es:si]
   100 00000208 3E8807                       mov       byte[ds:bx], al
   101 0000020B 43                           inc       bx
   102 0000020C 41                           inc       cx
   103 0000020D 46                           inc       si
   104 0000020E 31C0                         xor       ax, ax
   105 00000210 A0[3700]                     mov       al, byte[fileNameLength]
   106 00000213 39C1                         cmp       cx, ax
   107 00000215 75EE                         jne        .LoopFileNameEntry
   108                                  
   109 00000217 3EC60700                     mov       byte[ds:bx],0
   110                                  
   111 0000021B BE[3800]                     mov       si, fileNameEntry
   112 0000021E 57                           push      di
   113 0000021F BF[2300]                     mov       di, fileName
   114                                      
   115                                  .CompareLoop:
   116 00000222 8A04                         mov       al, byte[si]                                          ;grab byte from ESI
   117 00000224 8A1D                         mov       bl, byte[di]                                          ;grab byte from EDI
   118 00000226 38D8                         cmp       al, bl                                                ;compare if they are equal
   119 00000228 7508                         jne       .notequal                                             ;they aren't equal
   120 0000022A 20C0                         and       al, al                                                ;both bytes are null
   121 0000022C 7407                         jz        .compareDone
   122 0000022E 47                           inc       di                                                    ;increment EDI
   123 0000022F 46                           inc       si                                                    ;increment ESI
   124 00000230 EBF0                         jmp       .CompareLoop                                          ;start looping
   125                                  .notequal:
   126 00000232 F9                           stc                                                             ;set the carry flag to indicate failure
   127 00000233 EB01                         jmp       .compareEnd
   128                                  .compareDone:
   129 00000235 F8                           clc                                                             ;clear the carry flag to indicate success
   130                                  .compareEnd:
   131 00000236 5F                           pop       di
   132 00000237 7328                         jnc       .nextsector
   133 00000239 31C9                         xor       cx, cx                                                ;prepare CX to do math for DI
   134 0000023B 8A0E[2E00]                   mov       cl, byte[directoryEntrySize]                          ;get the size of the directory entry
   135 0000023F 01CF                         add       di, cx                                                ;add that size to the DI to get to the next record
   136 00000241 26803D00                     cmp       byte[es:di],0                                         ;is the next entry = 0?
   137 00000245 0F8472FF                     je        notbootable                                           ;if so, we're at the end of the directory, move on
   138 00000249 31C9                         xor       cx, cx
   139 0000024B BB[3800]                     mov       bx, fileNameEntry
   140                                  .clearFileNameEntry:
   141 0000024E 3EC60700                     mov       byte[ds:bx],0                                         ;erase the begining
   142 00000252 43                           inc       bx
   143 00000253 41                           inc       cx
   144 00000254 81F9FE00                     cmp       cx, 254
   145 00000258 72F4                         jb        .clearFileNameEntry
   146 0000025A 3EC60700                     mov       byte[ds:bx],0
   147 0000025E E972FF                       jmp       searchbootfile.nextdirentry    
   148                                  .nextsector:     
   149 00000261 66A1[2F00]                   mov       eax, dword[fileSector]
   150 00000265 66A3[5301]                   mov       dword[diskAddressPacket.start_absolute_sector], eax   ;save the starting sector into DAP
   151 00000269 66A1[3300]                   mov       eax, dword[fileSize]
   152 0000026D 6631D2                       xor       edx, edx
   153 00000270 66BB00080000                 mov       ebx, 2048
   154 00000276 66F7F3                       div       ebx
   155 00000279 6640                         inc       eax
   156 0000027B A3[4D01]                     mov       [diskAddressPacket.sectors_to_read],AX                ;save number of sectors to read
   157 0000027E 8A16[0500]                   mov       dl, byte[bootdrive]                                   ;set it up again
   158 00000282 B442                         mov       ah,0x42                                               ;read from drive function
   159 00000284 BE[4B01]                     mov       si,diskAddressPacket                                  ;load SI with address of the Disk Address Packet
   160 00000287 CD13                         int       0x13                                                  ;call read sector from drive
   161 00000289 0F822EFF                     jc        notbootable                                           ;nope, hosed, get out
   162 0000028D 8A16[0500]                   mov       dl,byte[bootdrive]                                    ;drive into DL for booting
   163 00000291 EA00007000                   jmp       KERNELSTARTCS:KERNELSTARTIP
