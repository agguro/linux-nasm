<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>/home/agguro/Documents/tiny8086/8086tiny/8086tiny.c</title><meta charset="utf-8"><style>body{margin:0;padding:0;tab-size:4}
/*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #F0F0F0;
}


/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

/*

Google Code style (c) Aahan Krish <geekpanth3r@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: white;
  color: black;
}

.hljs-comment,
.hljs-quote {
  color: #800;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-title,
.hljs-name {
  color: #008;
}

.hljs-variable,
.hljs-template-variable {
  color: #660;
}

.hljs-string,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-regexp {
  color: #080;
}

.hljs-literal,
.hljs-symbol,
.hljs-bullet,
.hljs-meta,
.hljs-number,
.hljs-link {
  color: #066;
}

.hljs-title,
.hljs-doctag,
.hljs-type,
.hljs-attr,
.hljs-built_in,
.hljs-builtin-name,
.hljs-params {
  color: #606;
}

.hljs-attribute,
.hljs-subst {
  color: #000;
}

.hljs-formula {
  background-color: #eee;
  font-style: italic;
}

.hljs-selector-id,
.hljs-selector-class {
  color: #9B703F
}

.hljs-addition {
  background-color: #baeeba;
}

.hljs-deletion {
  background-color: #ffc8bd;
}

.hljs-doctag,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}


/* Line numbers */

table {
  border: none;
  border-collapse: collapse;
}
.line-number {
  border-right: thin solid silver;
  padding-right: 0.3em;
  text-align: right;
  vertical-align: top;
}
.line-text {
  margin-left: 0.7em;
  padding-bottom: 0em;
  white-space: pre-wrap;
}

.hljs { max-width:100%; width:100%; font-family: "'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'", monospace; font-size: 10pt; }
</style></head><body><table class="hljs"><tbody><tr><td class="line-number">1</td><td class="line-text"><span class="hljs-comment">// 8086tiny: a tiny, highly functional, highly portable PC emulator/VM</span></td></tr>
<tr><td class="line-number">2</td><td class="line-text"><span class="hljs-comment">// Copyright 2013-14, Adrian Cable (adrian.cable@gmail.com) - http://www.megalith.co.uk/8086tiny</span></td></tr>
<tr><td class="line-number">3</td><td class="line-text"><span class="hljs-comment">//</span></td></tr>
<tr><td class="line-number">4</td><td class="line-text"><span class="hljs-comment">// Revision 1.25</span></td></tr>
<tr><td class="line-number">5</td><td class="line-text"><span class="hljs-comment">//</span></td></tr>
<tr><td class="line-number">6</td><td class="line-text"><span class="hljs-comment">// This work is licensed under the MIT License. See included LICENSE.TXT.</span></td></tr>
<tr><td class="line-number">7</td><td class="line-text"></td></tr>
<tr><td class="line-number">8</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span></td></tr>
<tr><td class="line-number">9</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/timeb.h&gt;</span></span></td></tr>
<tr><td class="line-number">10</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory.h&gt;</span></span></td></tr>
<tr><td class="line-number">11</td><td class="line-text"></td></tr>
<tr><td class="line-number">12</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _WIN32</span></td></tr>
<tr><td class="line-number">13</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span></td></tr>
<tr><td class="line-number">14</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span></td></tr>
<tr><td class="line-number">15</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">16</td><td class="line-text"></td></tr>
<tr><td class="line-number">17</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">18</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SDL.h"</span></span></td></tr>
<tr><td class="line-number">19</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">20</td><td class="line-text"></td></tr>
<tr><td class="line-number">21</td><td class="line-text"><span class="hljs-comment">// Emulator system constants</span></td></tr>
<tr><td class="line-number">22</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IO_PORT_COUNT 0x10000</span></td></tr>
<tr><td class="line-number">23</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_SIZE 0x10FFF0</span></td></tr>
<tr><td class="line-number">24</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REGS_BASE 0xF0000</span></td></tr>
<tr><td class="line-number">25</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_RAM_SIZE 0x10000</span></td></tr>
<tr><td class="line-number">26</td><td class="line-text"></td></tr>
<tr><td class="line-number">27</td><td class="line-text"><span class="hljs-comment">// Graphics/timer/keyboard update delays (explained later)</span></td></tr>
<tr><td class="line-number">28</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> GRAPHICS_UPDATE_DELAY</span></td></tr>
<tr><td class="line-number">29</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRAPHICS_UPDATE_DELAY 360000</span></td></tr>
<tr><td class="line-number">30</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">31</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KEYBOARD_TIMER_UPDATE_DELAY 20000</span></td></tr>
<tr><td class="line-number">32</td><td class="line-text"></td></tr>
<tr><td class="line-number">33</td><td class="line-text"><span class="hljs-comment">// 16-bit register decodes</span></td></tr>
<tr><td class="line-number">34</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_AX 0</span></td></tr>
<tr><td class="line-number">35</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_CX 1</span></td></tr>
<tr><td class="line-number">36</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_DX 2</span></td></tr>
<tr><td class="line-number">37</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_BX 3</span></td></tr>
<tr><td class="line-number">38</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_SP 4</span></td></tr>
<tr><td class="line-number">39</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_BP 5</span></td></tr>
<tr><td class="line-number">40</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_SI 6</span></td></tr>
<tr><td class="line-number">41</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_DI 7</span></td></tr>
<tr><td class="line-number">42</td><td class="line-text"></td></tr>
<tr><td class="line-number">43</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_ES 8</span></td></tr>
<tr><td class="line-number">44</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_CS 9</span></td></tr>
<tr><td class="line-number">45</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_SS 10</span></td></tr>
<tr><td class="line-number">46</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_DS 11</span></td></tr>
<tr><td class="line-number">47</td><td class="line-text"></td></tr>
<tr><td class="line-number">48</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_ZERO 12</span></td></tr>
<tr><td class="line-number">49</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_SCRATCH 13</span></td></tr>
<tr><td class="line-number">50</td><td class="line-text"></td></tr>
<tr><td class="line-number">51</td><td class="line-text"><span class="hljs-comment">// 8-bit register decodes</span></td></tr>
<tr><td class="line-number">52</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_AL 0</span></td></tr>
<tr><td class="line-number">53</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_AH 1</span></td></tr>
<tr><td class="line-number">54</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_CL 2</span></td></tr>
<tr><td class="line-number">55</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_CH 3</span></td></tr>
<tr><td class="line-number">56</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_DL 4</span></td></tr>
<tr><td class="line-number">57</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_DH 5</span></td></tr>
<tr><td class="line-number">58</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_BL 6</span></td></tr>
<tr><td class="line-number">59</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG_BH 7</span></td></tr>
<tr><td class="line-number">60</td><td class="line-text"></td></tr>
<tr><td class="line-number">61</td><td class="line-text"><span class="hljs-comment">// FLAGS register decodes</span></td></tr>
<tr><td class="line-number">62</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_CF 40</span></td></tr>
<tr><td class="line-number">63</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_PF 41</span></td></tr>
<tr><td class="line-number">64</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_AF 42</span></td></tr>
<tr><td class="line-number">65</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_ZF 43</span></td></tr>
<tr><td class="line-number">66</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_SF 44</span></td></tr>
<tr><td class="line-number">67</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_TF 45</span></td></tr>
<tr><td class="line-number">68</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_IF 46</span></td></tr>
<tr><td class="line-number">69</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_DF 47</span></td></tr>
<tr><td class="line-number">70</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAG_OF 48</span></td></tr>
<tr><td class="line-number">71</td><td class="line-text"></td></tr>
<tr><td class="line-number">72</td><td class="line-text"><span class="hljs-comment">// Lookup tables in the BIOS binary</span></td></tr>
<tr><td class="line-number">73</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_XLAT_OPCODE 8</span></td></tr>
<tr><td class="line-number">74</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_XLAT_SUBFUNCTION 9</span></td></tr>
<tr><td class="line-number">75</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_STD_FLAGS 10</span></td></tr>
<tr><td class="line-number">76</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_PARITY_FLAG 11</span></td></tr>
<tr><td class="line-number">77</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_BASE_INST_SIZE 12</span></td></tr>
<tr><td class="line-number">78</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_I_W_SIZE 13</span></td></tr>
<tr><td class="line-number">79</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_I_MOD_SIZE 14</span></td></tr>
<tr><td class="line-number">80</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_COND_JUMP_DECODE_A 15</span></td></tr>
<tr><td class="line-number">81</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_COND_JUMP_DECODE_B 16</span></td></tr>
<tr><td class="line-number">82</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_COND_JUMP_DECODE_C 17</span></td></tr>
<tr><td class="line-number">83</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_COND_JUMP_DECODE_D 18</span></td></tr>
<tr><td class="line-number">84</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TABLE_FLAGS_BITFIELDS 19</span></td></tr>
<tr><td class="line-number">85</td><td class="line-text"></td></tr>
<tr><td class="line-number">86</td><td class="line-text"><span class="hljs-comment">// Bitfields for TABLE_STD_FLAGS values</span></td></tr>
<tr><td class="line-number">87</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAGS_UPDATE_SZP 1</span></td></tr>
<tr><td class="line-number">88</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAGS_UPDATE_AO_ARITH 2</span></td></tr>
<tr><td class="line-number">89</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLAGS_UPDATE_OC_LOGIC 4</span></td></tr>
<tr><td class="line-number">90</td><td class="line-text"></td></tr>
<tr><td class="line-number">91</td><td class="line-text"><span class="hljs-comment">// Helper macros</span></td></tr>
<tr><td class="line-number">92</td><td class="line-text"></td></tr>
<tr><td class="line-number">93</td><td class="line-text"><span class="hljs-comment">// Decode mod, r_m and reg fields in instruction</span></td></tr>
<tr><td class="line-number">94</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECODE_RM_REG scratch2_uint = 4 * !i_mod, \</span></td></tr>
<tr><td class="line-number">95</td><td class="line-text">					  
op_to_addr = rm_addr = i_mod &lt; 3 ? SEGREG(seg_override_en ? 
seg_override : bios_table_lookup[scratch2_uint + 3][i_rm], 
bios_table_lookup[scratch2_uint][i_rm], 
regs16[bios_table_lookup[scratch2_uint + 1][i_rm]] + 
bios_table_lookup[scratch2_uint + 2][i_rm] * i_data1+) : 
GET_REG_ADDR(i_rm), \</td></tr>
<tr><td class="line-number">96</td><td class="line-text">					  op_from_addr = GET_REG_ADDR(i_reg), \</td></tr>
<tr><td class="line-number">97</td><td class="line-text">					  i_d &amp;&amp; (scratch_uint = op_from_addr, op_from_addr = rm_addr, op_to_addr = scratch_uint)</td></tr>
<tr><td class="line-number">98</td><td class="line-text"></td></tr>
<tr><td class="line-number">99</td><td class="line-text"><span class="hljs-comment">// Return memory-mapped register location (offset into mem array) for register #reg_id</span></td></tr>
<tr><td class="line-number">100</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_REG_ADDR(reg_id) (REGS_BASE + (i_w ? 2 * reg_id : 2 * reg_id + reg_id / 4 &amp; 7))</span></td></tr>
<tr><td class="line-number">101</td><td class="line-text"></td></tr>
<tr><td class="line-number">102</td><td class="line-text"><span class="hljs-comment">// Returns number of top bit in operand (i.e. 8 for 8-bit operands, 16 for 16-bit operands)</span></td></tr>
<tr><td class="line-number">103</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOP_BIT 8*(i_w + 1)</span></td></tr>
<tr><td class="line-number">104</td><td class="line-text"></td></tr>
<tr><td class="line-number">105</td><td class="line-text"><span class="hljs-comment">// Opcode execution unit helpers</span></td></tr>
<tr><td class="line-number">106</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OPCODE ;break; case</span></td></tr>
<tr><td class="line-number">107</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OPCODE_CHAIN ; case</span></td></tr>
<tr><td class="line-number">108</td><td class="line-text"></td></tr>
<tr><td class="line-number">109</td><td class="line-text"><span class="hljs-comment">// [I]MUL/[I]DIV/DAA/DAS/ADC/SBB helpers</span></td></tr>
<tr><td class="line-number">110</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUL_MACRO(op_data_type,out_regs) (set_opcode(0x10), \</span></td></tr>
<tr><td class="line-number">111</td><td class="line-text">										  out_regs[i_w + 1] = (op_result = CAST(op_data_type)mem[rm_addr] * (op_data_type)*out_regs) &gt;&gt; 16, \</td></tr>
<tr><td class="line-number">112</td><td class="line-text">										  regs16[REG_AX] = op_result, \</td></tr>
<tr><td class="line-number">113</td><td class="line-text">										  set_OF(set_CF(op_result - (op_data_type)op_result)))</td></tr>
<tr><td class="line-number">114</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DIV_MACRO(out_data_type,in_data_type,out_regs) (scratch_int = CAST(out_data_type)mem[rm_addr]) &amp;&amp; !(scratch2_uint = (in_data_type)(scratch_uint = (out_regs[i_w+1] &lt;&lt; 16) + regs16[REG_AX]) / scratch_int, scratch2_uint - (out_data_type)scratch2_uint) ? out_regs[i_w+1] = scratch_uint - scratch_int * (*out_regs = scratch2_uint) : pc_interrupt(0)</span></td></tr>
<tr><td class="line-number">115</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DAA_DAS(op1,op2,mask,min) set_AF((((scratch2_uint = regs8[REG_AL]) &amp; 0x0F) &gt; 9) || regs8[FLAG_AF]) &amp;&amp; (op_result = regs8[REG_AL] op1 6, set_CF(regs8[FLAG_CF] || (regs8[REG_AL] op2 scratch2_uint))), \</span></td></tr>
<tr><td class="line-number">116</td><td class="line-text">								  
set_CF((((mask &amp; 1 ? scratch2_uint : regs8[REG_AL]) &amp; mask) &gt;
 min) || regs8[FLAG_CF]) &amp;&amp; (op_result = regs8[REG_AL] op1 0x60)</td></tr>
<tr><td class="line-number">117</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADC_SBB_MACRO(a) OP(a##= regs8[FLAG_CF] +), \</span></td></tr>
<tr><td class="line-number">118</td><td class="line-text">						 set_CF(regs8[FLAG_CF] &amp;&amp; (op_result == op_dest) || (a op_result &lt; a(int)op_dest)), \</td></tr>
<tr><td class="line-number">119</td><td class="line-text">						 set_AF_OF_arith()</td></tr>
<tr><td class="line-number">120</td><td class="line-text"></td></tr>
<tr><td class="line-number">121</td><td class="line-text"><span class="hljs-comment">// Execute arithmetic/logic operations in emulator memory/registers</span></td></tr>
<tr><td class="line-number">122</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R_M_OP(dest,op,src) (i_w ? op_dest = CAST(unsigned short)dest, op_result = CAST(unsigned short)dest op (op_source = CAST(unsigned short)src) \</span></td></tr>
<tr><td class="line-number">123</td><td class="line-text">								 : (op_dest = dest, op_result = dest op (op_source = CAST(unsigned char)src)))</td></tr>
<tr><td class="line-number">124</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_OP(dest,op,src) R_M_OP(mem[dest],op,mem[src])</span></td></tr>
<tr><td class="line-number">125</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OP(op) MEM_OP(op_to_addr,op,op_from_addr)</span></td></tr>
<tr><td class="line-number">126</td><td class="line-text"></td></tr>
<tr><td class="line-number">127</td><td class="line-text"><span class="hljs-comment">// Increment or decrement a register #reg_id (usually SI or DI), depending on direction flag and operand size (given by i_w)</span></td></tr>
<tr><td class="line-number">128</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INDEX_INC(reg_id) (regs16[reg_id] -= (2 * regs8[FLAG_DF] - 1)*(i_w + 1))</span></td></tr>
<tr><td class="line-number">129</td><td class="line-text"></td></tr>
<tr><td class="line-number">130</td><td class="line-text"><span class="hljs-comment">// Helpers for stack operations</span></td></tr>
<tr><td class="line-number">131</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R_M_PUSH(a) (i_w = 1, R_M_OP(mem[SEGREG(REG_SS, REG_SP, --)], =, a))</span></td></tr>
<tr><td class="line-number">132</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R_M_POP(a) (i_w = 1, regs16[REG_SP] += 2, R_M_OP(a, =, mem[SEGREG(REG_SS, REG_SP, -2+)]))</span></td></tr>
<tr><td class="line-number">133</td><td class="line-text"></td></tr>
<tr><td class="line-number">134</td><td class="line-text"><span class="hljs-comment">// Convert segment:offset to linear address in emulator memory space</span></td></tr>
<tr><td class="line-number">135</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEGREG(reg_seg,reg_ofs,op) 16 * regs16[reg_seg] + (unsigned short)(op regs16[reg_ofs])</span></td></tr>
<tr><td class="line-number">136</td><td class="line-text"></td></tr>
<tr><td class="line-number">137</td><td class="line-text"><span class="hljs-comment">// Returns sign bit of an 8-bit or 16-bit operand</span></td></tr>
<tr><td class="line-number">138</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIGN_OF(a) (1 &amp; (i_w ? CAST(short)a : a) &gt;&gt; (TOP_BIT - 1))</span></td></tr>
<tr><td class="line-number">139</td><td class="line-text"></td></tr>
<tr><td class="line-number">140</td><td class="line-text"><span class="hljs-comment">// Reinterpretation cast</span></td></tr>
<tr><td class="line-number">141</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAST(a) *(a*)&amp;</span></td></tr>
<tr><td class="line-number">142</td><td class="line-text"></td></tr>
<tr><td class="line-number">143</td><td class="line-text"><span class="hljs-comment">// Keyboard driver for console. This may need changing for UNIX/non-UNIX platforms</span></td></tr>
<tr><td class="line-number">144</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span></td></tr>
<tr><td class="line-number">145</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KEYBOARD_DRIVER kbhit() &amp;&amp; (mem[0x4A6] = getch(), pc_interrupt(7))</span></td></tr>
<tr><td class="line-number">146</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></td></tr>
<tr><td class="line-number">147</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KEYBOARD_DRIVER read(0, mem + 0x4A6, 1) &amp;&amp; (int8_asap = (mem[0x4A6] == 0x1B), pc_interrupt(7))</span></td></tr>
<tr><td class="line-number">148</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">149</td><td class="line-text"></td></tr>
<tr><td class="line-number">150</td><td class="line-text"><span class="hljs-comment">// Keyboard driver for SDL</span></td></tr>
<tr><td class="line-number">151</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">152</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_KEYBOARD_DRIVER KEYBOARD_DRIVER</span></td></tr>
<tr><td class="line-number">153</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></td></tr>
<tr><td class="line-number">154</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_KEYBOARD_DRIVER sdl_screen ? SDL_PollEvent(&amp;sdl_event) &amp;&amp; (sdl_event.type == SDL_KEYDOWN || sdl_event.type == SDL_KEYUP) &amp;&amp; (scratch_uint = sdl_event.key.keysym.unicode, scratch2_uint = sdl_event.key.keysym.mod, CAST(short)mem[0x4A6] = 0x400 + 0x800*!!(scratch2_uint &amp; KMOD_ALT) + 0x1000*!!(scratch2_uint &amp; KMOD_SHIFT) + 0x2000*!!(scratch2_uint &amp; KMOD_CTRL) + 0x4000*(sdl_event.type == SDL_KEYUP) + ((!scratch_uint || scratch_uint &gt; 0x7F) ? sdl_event.key.keysym.sym : scratch_uint), pc_interrupt(7)) : (KEYBOARD_DRIVER)</span></td></tr>
<tr><td class="line-number">155</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">156</td><td class="line-text"></td></tr>
<tr><td class="line-number">157</td><td class="line-text"><span class="hljs-comment">// Global variable definitions</span></td></tr>
<tr><td class="line-number">158</td><td class="line-text"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>
 mem[RAM_SIZE], io_ports[IO_PORT_COUNT], *opcode_stream, *regs8, i_rm, 
i_w, i_reg, i_mod, i_mod_size, i_d, i_reg4bit, raw_opcode_id, 
xlat_opcode_id, extra, rep_mode, seg_override_en, rep_override_en, 
trap_flag, int8_asap, scratch_uchar, io_hi_lo, *vid_mem_base, spkr_en, 
bios_table_lookup[<span class="hljs-number">20</span>][<span class="hljs-number">256</span>];</td></tr>
<tr><td class="line-number">159</td><td class="line-text"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *regs16, reg_ip, seg_override, file_index, wave_counter;</td></tr>
<tr><td class="line-number">160</td><td class="line-text"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>
 op_source, op_dest, rm_addr, op_to_addr, op_from_addr, i_data0, 
i_data1, i_data2, scratch_uint, scratch2_uint, inst_counter, 
set_flags_type, GRAPHICS_X, GRAPHICS_Y, pixel_colors[<span class="hljs-number">16</span>], vmem_ctr;</td></tr>
<tr><td class="line-number">161</td><td class="line-text"><span class="hljs-keyword">int</span> op_result, disk[<span class="hljs-number">3</span>], scratch_int;</td></tr>
<tr><td class="line-number">162</td><td class="line-text"><span class="hljs-keyword">time_t</span> clock_buf;</td></tr>
<tr><td class="line-number">163</td><td class="line-text"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeb</span> <span class="hljs-title">ms_clock</span>;</span></td></tr>
<tr><td class="line-number">164</td><td class="line-text"></td></tr>
<tr><td class="line-number">165</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">166</td><td class="line-text">SDL_AudioSpec sdl_audio = {<span class="hljs-number">44100</span>, AUDIO_U8, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>};</td></tr>
<tr><td class="line-number">167</td><td class="line-text">SDL_Surface *sdl_screen;</td></tr>
<tr><td class="line-number">168</td><td class="line-text">SDL_Event sdl_event;</td></tr>
<tr><td class="line-number">169</td><td class="line-text"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> vid_addr_lookup[VIDEO_RAM_SIZE], cga_colors[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span> <span class="hljs-comment">/* Black */</span>, <span class="hljs-number">0x1F1F</span> <span class="hljs-comment">/* Cyan */</span>, <span class="hljs-number">0xE3E3</span> <span class="hljs-comment">/* Magenta */</span>, <span class="hljs-number">0xFFFF</span> <span class="hljs-comment">/* White */</span>};</td></tr>
<tr><td class="line-number">170</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">171</td><td class="line-text"></td></tr>
<tr><td class="line-number">172</td><td class="line-text"><span class="hljs-comment">// Helper functions</span></td></tr>
<tr><td class="line-number">173</td><td class="line-text"></td></tr>
<tr><td class="line-number">174</td><td class="line-text"><span class="hljs-comment">// Set carry flag</span></td></tr>
<tr><td class="line-number">175</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">set_CF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> new_CF)</span></span></td></tr>
<tr><td class="line-number">176</td><td class="line-text">{</td></tr>
<tr><td class="line-number">177</td><td class="line-text">	<span class="hljs-keyword">return</span> regs8[FLAG_CF] = !!new_CF;</td></tr>
<tr><td class="line-number">178</td><td class="line-text">}</td></tr>
<tr><td class="line-number">179</td><td class="line-text"></td></tr>
<tr><td class="line-number">180</td><td class="line-text"><span class="hljs-comment">// Set auxiliary flag</span></td></tr>
<tr><td class="line-number">181</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">set_AF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> new_AF)</span></span></td></tr>
<tr><td class="line-number">182</td><td class="line-text">{</td></tr>
<tr><td class="line-number">183</td><td class="line-text">	<span class="hljs-keyword">return</span> regs8[FLAG_AF] = !!new_AF;</td></tr>
<tr><td class="line-number">184</td><td class="line-text">}</td></tr>
<tr><td class="line-number">185</td><td class="line-text"></td></tr>
<tr><td class="line-number">186</td><td class="line-text"><span class="hljs-comment">// Set overflow flag</span></td></tr>
<tr><td class="line-number">187</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">set_OF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> new_OF)</span></span></td></tr>
<tr><td class="line-number">188</td><td class="line-text">{</td></tr>
<tr><td class="line-number">189</td><td class="line-text">	<span class="hljs-keyword">return</span> regs8[FLAG_OF] = !!new_OF;</td></tr>
<tr><td class="line-number">190</td><td class="line-text">}</td></tr>
<tr><td class="line-number">191</td><td class="line-text"></td></tr>
<tr><td class="line-number">192</td><td class="line-text"><span class="hljs-comment">// Set auxiliary and overflow flag after arithmetic operations</span></td></tr>
<tr><td class="line-number">193</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">set_AF_OF_arith</span><span class="hljs-params">()</span></span></td></tr>
<tr><td class="line-number">194</td><td class="line-text">{</td></tr>
<tr><td class="line-number">195</td><td class="line-text">	set_AF((op_source ^= op_dest ^ op_result) &amp; <span class="hljs-number">0x10</span>);</td></tr>
<tr><td class="line-number">196</td><td class="line-text">	<span class="hljs-keyword">if</span> (op_result == op_dest)</td></tr>
<tr><td class="line-number">197</td><td class="line-text">		<span class="hljs-keyword">return</span> set_OF(<span class="hljs-number">0</span>);</td></tr>
<tr><td class="line-number">198</td><td class="line-text">	<span class="hljs-keyword">else</span></td></tr>
<tr><td class="line-number">199</td><td class="line-text">		<span class="hljs-keyword">return</span> set_OF(<span class="hljs-number">1</span> &amp; (regs8[FLAG_CF] ^ op_source &gt;&gt; (TOP_BIT - <span class="hljs-number">1</span>)));</td></tr>
<tr><td class="line-number">200</td><td class="line-text">}</td></tr>
<tr><td class="line-number">201</td><td class="line-text"></td></tr>
<tr><td class="line-number">202</td><td class="line-text"><span class="hljs-comment">// Assemble and return emulated CPU FLAGS register in scratch_uint</span></td></tr>
<tr><td class="line-number">203</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make_flags</span><span class="hljs-params">()</span></span></td></tr>
<tr><td class="line-number">204</td><td class="line-text">{</td></tr>
<tr><td class="line-number">205</td><td class="line-text">	scratch_uint = <span class="hljs-number">0xF002</span>; <span class="hljs-comment">// 8086 has reserved and unused flags set to 1</span></td></tr>
<tr><td class="line-number">206</td><td class="line-text">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>; i--;)</td></tr>
<tr><td class="line-number">207</td><td class="line-text">		scratch_uint += regs8[FLAG_CF + i] &lt;&lt; bios_table_lookup[TABLE_FLAGS_BITFIELDS][i];</td></tr>
<tr><td class="line-number">208</td><td class="line-text">}</td></tr>
<tr><td class="line-number">209</td><td class="line-text"></td></tr>
<tr><td class="line-number">210</td><td class="line-text"><span class="hljs-comment">// Set emulated CPU FLAGS register from regs8[FLAG_xx] values</span></td></tr>
<tr><td class="line-number">211</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_flags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> new_flags)</span></span></td></tr>
<tr><td class="line-number">212</td><td class="line-text">{</td></tr>
<tr><td class="line-number">213</td><td class="line-text">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>; i--;)</td></tr>
<tr><td class="line-number">214</td><td class="line-text">		regs8[FLAG_CF + i] = !!(<span class="hljs-number">1</span> &lt;&lt; bios_table_lookup[TABLE_FLAGS_BITFIELDS][i] &amp; new_flags);</td></tr>
<tr><td class="line-number">215</td><td class="line-text">}</td></tr>
<tr><td class="line-number">216</td><td class="line-text"></td></tr>
<tr><td class="line-number">217</td><td class="line-text"><span class="hljs-comment">// Convert raw opcode to translated opcode index. This condenses a large number of different encodings of similar</span></td></tr>
<tr><td class="line-number">218</td><td class="line-text"><span class="hljs-comment">// instructions into a much smaller number of distinct functions, which we then execute</span></td></tr>
<tr><td class="line-number">219</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_opcode</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> opcode)</span></span></td></tr>
<tr><td class="line-number">220</td><td class="line-text">{</td></tr>
<tr><td class="line-number">221</td><td class="line-text">	xlat_opcode_id = bios_table_lookup[TABLE_XLAT_OPCODE][raw_opcode_id = opcode];</td></tr>
<tr><td class="line-number">222</td><td class="line-text">	extra = bios_table_lookup[TABLE_XLAT_SUBFUNCTION][opcode];</td></tr>
<tr><td class="line-number">223</td><td class="line-text">	i_mod_size = bios_table_lookup[TABLE_I_MOD_SIZE][opcode];</td></tr>
<tr><td class="line-number">224</td><td class="line-text">	set_flags_type = bios_table_lookup[TABLE_STD_FLAGS][opcode];</td></tr>
<tr><td class="line-number">225</td><td class="line-text">}</td></tr>
<tr><td class="line-number">226</td><td class="line-text"></td></tr>
<tr><td class="line-number">227</td><td class="line-text"><span class="hljs-comment">// Execute INT #interrupt_num on the emulated machine</span></td></tr>
<tr><td class="line-number">228</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">pc_interrupt</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> interrupt_num)</span></span></td></tr>
<tr><td class="line-number">229</td><td class="line-text">{</td></tr>
<tr><td class="line-number">230</td><td class="line-text">	set_opcode(<span class="hljs-number">0xCD</span>); <span class="hljs-comment">// Decode like INT</span></td></tr>
<tr><td class="line-number">231</td><td class="line-text"></td></tr>
<tr><td class="line-number">232</td><td class="line-text">	make_flags();</td></tr>
<tr><td class="line-number">233</td><td class="line-text">	R_M_PUSH(scratch_uint);</td></tr>
<tr><td class="line-number">234</td><td class="line-text">	R_M_PUSH(regs16[REG_CS]);</td></tr>
<tr><td class="line-number">235</td><td class="line-text">	R_M_PUSH(reg_ip);</td></tr>
<tr><td class="line-number">236</td><td class="line-text">	MEM_OP(REGS_BASE + <span class="hljs-number">2</span> * REG_CS, =, <span class="hljs-number">4</span> * interrupt_num + <span class="hljs-number">2</span>);</td></tr>
<tr><td class="line-number">237</td><td class="line-text">	R_M_OP(reg_ip, =, mem[<span class="hljs-number">4</span> * interrupt_num]);</td></tr>
<tr><td class="line-number">238</td><td class="line-text"></td></tr>
<tr><td class="line-number">239</td><td class="line-text">	<span class="hljs-keyword">return</span> regs8[FLAG_TF] = regs8[FLAG_IF] = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">240</td><td class="line-text">}</td></tr>
<tr><td class="line-number">241</td><td class="line-text"></td></tr>
<tr><td class="line-number">242</td><td class="line-text"><span class="hljs-comment">// AAA and AAS instructions - which_operation is +1 for AAA, and -1 for AAS</span></td></tr>
<tr><td class="line-number">243</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">AAA_AAS</span><span class="hljs-params">(<span class="hljs-keyword">char</span> which_operation)</span></span></td></tr>
<tr><td class="line-number">244</td><td class="line-text">{</td></tr>
<tr><td class="line-number">245</td><td class="line-text">	<span class="hljs-keyword">return</span> (regs16[REG_AX] += <span class="hljs-number">262</span> * which_operation*set_AF(set_CF(((regs8[REG_AL] &amp; <span class="hljs-number">0x0F</span>) &gt; <span class="hljs-number">9</span>) || regs8[FLAG_AF])), regs8[REG_AL] &amp;= <span class="hljs-number">0x0F</span>);</td></tr>
<tr><td class="line-number">246</td><td class="line-text">}</td></tr>
<tr><td class="line-number">247</td><td class="line-text"></td></tr>
<tr><td class="line-number">248</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">249</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *stream, <span class="hljs-keyword">int</span> len)</span></span></td></tr>
<tr><td class="line-number">250</td><td class="line-text">{</td></tr>
<tr><td class="line-number">251</td><td class="line-text">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)</td></tr>
<tr><td class="line-number">252</td><td class="line-text">		stream[i] = (spkr_en == <span class="hljs-number">3</span>) &amp;&amp; CAST(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>)mem[<span class="hljs-number">0x4AA</span>] ? -((<span class="hljs-number">54</span> * wave_counter++ / CAST(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>)mem[<span class="hljs-number">0x4AA</span>]) &amp; <span class="hljs-number">1</span>) : sdl_audio.silence;</td></tr>
<tr><td class="line-number">253</td><td class="line-text"></td></tr>
<tr><td class="line-number">254</td><td class="line-text">	spkr_en = io_ports[<span class="hljs-number">0x61</span>] &amp; <span class="hljs-number">3</span>;</td></tr>
<tr><td class="line-number">255</td><td class="line-text">}</td></tr>
<tr><td class="line-number">256</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">257</td><td class="line-text"></td></tr>
<tr><td class="line-number">258</td><td class="line-text"><span class="hljs-comment">// Emulator entry point</span></td></tr>
<tr><td class="line-number">259</td><td class="line-text"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span></td></tr>
<tr><td class="line-number">260</td><td class="line-text">{</td></tr>
<tr><td class="line-number">261</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">262</td><td class="line-text">	<span class="hljs-comment">// Initialise SDL</span></td></tr>
<tr><td class="line-number">263</td><td class="line-text">	SDL_Init(SDL_INIT_AUDIO);</td></tr>
<tr><td class="line-number">264</td><td class="line-text">	sdl_audio.callback = audio_callback;</td></tr>
<tr><td class="line-number">265</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span></td></tr>
<tr><td class="line-number">266</td><td class="line-text">	sdl_audio.samples = <span class="hljs-number">512</span>;</td></tr>
<tr><td class="line-number">267</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">268</td><td class="line-text">	SDL_OpenAudio(&amp;sdl_audio, <span class="hljs-number">0</span>);</td></tr>
<tr><td class="line-number">269</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">270</td><td class="line-text"></td></tr>
<tr><td class="line-number">271</td><td class="line-text">	<span class="hljs-comment">// regs16 and reg8 point to F000:0, the start of memory-mapped registers. CS is initialised to F000</span></td></tr>
<tr><td class="line-number">272</td><td class="line-text">	regs16 = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *)(regs8 = mem + REGS_BASE);</td></tr>
<tr><td class="line-number">273</td><td class="line-text">	regs16[REG_CS] = <span class="hljs-number">0xF000</span>;</td></tr>
<tr><td class="line-number">274</td><td class="line-text"></td></tr>
<tr><td class="line-number">275</td><td class="line-text">	<span class="hljs-comment">// Trap flag off</span></td></tr>
<tr><td class="line-number">276</td><td class="line-text">	regs8[FLAG_TF] = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">277</td><td class="line-text"></td></tr>
<tr><td class="line-number">278</td><td class="line-text">	<span class="hljs-comment">// Set DL equal to the boot device: 0 for the FD, or 0x80 for the HD. Normally, boot from the FD.</span></td></tr>
<tr><td class="line-number">279</td><td class="line-text">	<span class="hljs-comment">// But, if the HD image file is prefixed with @, then boot from the HD</span></td></tr>
<tr><td class="line-number">280</td><td class="line-text">	regs8[REG_DL] = ((argc &gt; <span class="hljs-number">3</span>) &amp;&amp; (*argv[<span class="hljs-number">3</span>] == <span class="hljs-string">'@'</span>)) ? argv[<span class="hljs-number">3</span>]++, <span class="hljs-number">0x80</span> : <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">281</td><td class="line-text"></td></tr>
<tr><td class="line-number">282</td><td class="line-text">	<span class="hljs-comment">// Open BIOS (file id disk[2]), floppy disk image (disk[1]), and hard disk image (disk[0]) if specified</span></td></tr>
<tr><td class="line-number">283</td><td class="line-text">	<span class="hljs-keyword">for</span> (file_index = <span class="hljs-number">3</span>; file_index;)</td></tr>
<tr><td class="line-number">284</td><td class="line-text">		disk[--file_index] = *++argv ? open(*argv, <span class="hljs-number">32898</span>) : <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">285</td><td class="line-text"></td></tr>
<tr><td class="line-number">286</td><td class="line-text">	<span class="hljs-comment">// Set CX:AX equal to the hard disk image size, if present</span></td></tr>
<tr><td class="line-number">287</td><td class="line-text">	CAST(<span class="hljs-keyword">unsigned</span>)regs16[REG_AX] = *disk ? lseek(*disk, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) &gt;&gt; <span class="hljs-number">9</span> : <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">288</td><td class="line-text"></td></tr>
<tr><td class="line-number">289</td><td class="line-text">	<span class="hljs-comment">// Load BIOS image into F000:0100, and set IP to 0100</span></td></tr>
<tr><td class="line-number">290</td><td class="line-text">	read(disk[<span class="hljs-number">2</span>], regs8 + (reg_ip = <span class="hljs-number">0x100</span>), <span class="hljs-number">0xFF00</span>);</td></tr>
<tr><td class="line-number">291</td><td class="line-text"></td></tr>
<tr><td class="line-number">292</td><td class="line-text">	<span class="hljs-comment">// Load instruction decoding helper table</span></td></tr>
<tr><td class="line-number">293</td><td class="line-text">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)</td></tr>
<tr><td class="line-number">294</td><td class="line-text">		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++)</td></tr>
<tr><td class="line-number">295</td><td class="line-text">			bios_table_lookup[i][j] = regs8[regs16[<span class="hljs-number">0x81</span> + i] + j];</td></tr>
<tr><td class="line-number">296</td><td class="line-text"></td></tr>
<tr><td class="line-number">297</td><td class="line-text">	<span class="hljs-comment">// Instruction execution loop. Terminates if CS:IP = 0:0</span></td></tr>
<tr><td class="line-number">298</td><td class="line-text">	<span class="hljs-keyword">for</span> (; opcode_stream = mem + <span class="hljs-number">16</span> * regs16[REG_CS] + reg_ip, opcode_stream != mem;)</td></tr>
<tr><td class="line-number">299</td><td class="line-text">	{</td></tr>
<tr><td class="line-number">300</td><td class="line-text">		<span class="hljs-comment">// Set up variables to prepare for decoding an opcode</span></td></tr>
<tr><td class="line-number">301</td><td class="line-text">		set_opcode(*opcode_stream);</td></tr>
<tr><td class="line-number">302</td><td class="line-text"></td></tr>
<tr><td class="line-number">303</td><td class="line-text">		<span class="hljs-comment">// Extract i_w and i_d fields from instruction</span></td></tr>
<tr><td class="line-number">304</td><td class="line-text">		i_w = (i_reg4bit = raw_opcode_id &amp; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">305</td><td class="line-text">		i_d = i_reg4bit / <span class="hljs-number">2</span> &amp; <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">306</td><td class="line-text"></td></tr>
<tr><td class="line-number">307</td><td class="line-text">		<span class="hljs-comment">// Extract instruction data fields</span></td></tr>
<tr><td class="line-number">308</td><td class="line-text">		i_data0 = CAST(<span class="hljs-keyword">short</span>)opcode_stream[<span class="hljs-number">1</span>];</td></tr>
<tr><td class="line-number">309</td><td class="line-text">		i_data1 = CAST(<span class="hljs-keyword">short</span>)opcode_stream[<span class="hljs-number">2</span>];</td></tr>
<tr><td class="line-number">310</td><td class="line-text">		i_data2 = CAST(<span class="hljs-keyword">short</span>)opcode_stream[<span class="hljs-number">3</span>];</td></tr>
<tr><td class="line-number">311</td><td class="line-text"></td></tr>
<tr><td class="line-number">312</td><td class="line-text">		<span class="hljs-comment">// seg_override_en and rep_override_en contain number of instructions to hold segment override and REP prefix respectively</span></td></tr>
<tr><td class="line-number">313</td><td class="line-text">		<span class="hljs-keyword">if</span> (seg_override_en)</td></tr>
<tr><td class="line-number">314</td><td class="line-text">			seg_override_en--;</td></tr>
<tr><td class="line-number">315</td><td class="line-text">		<span class="hljs-keyword">if</span> (rep_override_en)</td></tr>
<tr><td class="line-number">316</td><td class="line-text">			rep_override_en--;</td></tr>
<tr><td class="line-number">317</td><td class="line-text"></td></tr>
<tr><td class="line-number">318</td><td class="line-text">		<span class="hljs-comment">// i_mod_size &gt; 0 indicates that opcode uses i_mod/i_rm/i_reg, so decode them</span></td></tr>
<tr><td class="line-number">319</td><td class="line-text">		<span class="hljs-keyword">if</span> (i_mod_size)</td></tr>
<tr><td class="line-number">320</td><td class="line-text">		{</td></tr>
<tr><td class="line-number">321</td><td class="line-text">			i_mod = (i_data0 &amp; <span class="hljs-number">0xFF</span>) &gt;&gt; <span class="hljs-number">6</span>;</td></tr>
<tr><td class="line-number">322</td><td class="line-text">			i_rm = i_data0 &amp; <span class="hljs-number">7</span>;</td></tr>
<tr><td class="line-number">323</td><td class="line-text">			i_reg = i_data0 / <span class="hljs-number">8</span> &amp; <span class="hljs-number">7</span>;</td></tr>
<tr><td class="line-number">324</td><td class="line-text"></td></tr>
<tr><td class="line-number">325</td><td class="line-text">			<span class="hljs-keyword">if</span> ((!i_mod &amp;&amp; i_rm == <span class="hljs-number">6</span>) || (i_mod == <span class="hljs-number">2</span>))</td></tr>
<tr><td class="line-number">326</td><td class="line-text">				i_data2 = CAST(<span class="hljs-keyword">short</span>)opcode_stream[<span class="hljs-number">4</span>];</td></tr>
<tr><td class="line-number">327</td><td class="line-text">			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i_mod != <span class="hljs-number">1</span>)</td></tr>
<tr><td class="line-number">328</td><td class="line-text">				i_data2 = i_data1;</td></tr>
<tr><td class="line-number">329</td><td class="line-text">			<span class="hljs-keyword">else</span> <span class="hljs-comment">// If i_mod is 1, operand is (usually) 8 bits rather than 16 bits</span></td></tr>
<tr><td class="line-number">330</td><td class="line-text">				i_data1 = (<span class="hljs-keyword">char</span>)i_data1;</td></tr>
<tr><td class="line-number">331</td><td class="line-text"></td></tr>
<tr><td class="line-number">332</td><td class="line-text">			DECODE_RM_REG;</td></tr>
<tr><td class="line-number">333</td><td class="line-text">		}</td></tr>
<tr><td class="line-number">334</td><td class="line-text"></td></tr>
<tr><td class="line-number">335</td><td class="line-text">		<span class="hljs-comment">// Instruction execution unit</span></td></tr>
<tr><td class="line-number">336</td><td class="line-text">		<span class="hljs-keyword">switch</span> (xlat_opcode_id)</td></tr>
<tr><td class="line-number">337</td><td class="line-text">		{</td></tr>
<tr><td class="line-number">338</td><td class="line-text">			OPCODE_CHAIN <span class="hljs-number">0</span>: <span class="hljs-comment">// Conditional jump (JAE, JNAE, etc.)</span></td></tr>
<tr><td class="line-number">339</td><td class="line-text">				<span class="hljs-comment">// i_w is the invert flag, e.g. i_w == 1 means JNAE, whereas i_w == 0 means JAE </span></td></tr>
<tr><td class="line-number">340</td><td class="line-text">				scratch_uchar = raw_opcode_id / <span class="hljs-number">2</span> &amp; <span class="hljs-number">7</span>;</td></tr>
<tr><td class="line-number">341</td><td class="line-text">				reg_ip += (<span class="hljs-keyword">char</span>)i_data0
 * (i_w ^ 
(regs8[bios_table_lookup[TABLE_COND_JUMP_DECODE_A][scratch_uchar]] || 
regs8[bios_table_lookup[TABLE_COND_JUMP_DECODE_B][scratch_uchar]] || 
regs8[bios_table_lookup[TABLE_COND_JUMP_DECODE_C][scratch_uchar]] ^ 
regs8[bios_table_lookup[TABLE_COND_JUMP_DECODE_D][scratch_uchar]]))</td></tr>
<tr><td class="line-number">342</td><td class="line-text">			OPCODE <span class="hljs-number">1</span>: <span class="hljs-comment">// MOV reg, imm</span></td></tr>
<tr><td class="line-number">343</td><td class="line-text">				i_w = !!(raw_opcode_id &amp; <span class="hljs-number">8</span>);</td></tr>
<tr><td class="line-number">344</td><td class="line-text">				R_M_OP(mem[GET_REG_ADDR(i_reg4bit)], =, i_data0)</td></tr>
<tr><td class="line-number">345</td><td class="line-text">			OPCODE <span class="hljs-number">3</span>: <span class="hljs-comment">// PUSH regs16</span></td></tr>
<tr><td class="line-number">346</td><td class="line-text">				R_M_PUSH(regs16[i_reg4bit])</td></tr>
<tr><td class="line-number">347</td><td class="line-text">			OPCODE <span class="hljs-number">4</span>: <span class="hljs-comment">// POP regs16</span></td></tr>
<tr><td class="line-number">348</td><td class="line-text">				R_M_POP(regs16[i_reg4bit])</td></tr>
<tr><td class="line-number">349</td><td class="line-text">			OPCODE <span class="hljs-number">2</span>: <span class="hljs-comment">// INC|DEC regs16</span></td></tr>
<tr><td class="line-number">350</td><td class="line-text">				i_w = <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">351</td><td class="line-text">				i_d = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">352</td><td class="line-text">				i_reg = i_reg4bit;</td></tr>
<tr><td class="line-number">353</td><td class="line-text">				DECODE_RM_REG;</td></tr>
<tr><td class="line-number">354</td><td class="line-text">				i_reg = extra</td></tr>
<tr><td class="line-number">355</td><td class="line-text">			OPCODE_CHAIN <span class="hljs-number">5</span>: <span class="hljs-comment">// INC|DEC|JMP|CALL|PUSH</span></td></tr>
<tr><td class="line-number">356</td><td class="line-text">				<span class="hljs-keyword">if</span> (i_reg &lt; <span class="hljs-number">2</span>) <span class="hljs-comment">// INC|DEC</span></td></tr>
<tr><td class="line-number">357</td><td class="line-text">					MEM_OP(op_from_addr, += <span class="hljs-number">1</span> - <span class="hljs-number">2</span> * i_reg +, REGS_BASE + <span class="hljs-number">2</span> * REG_ZERO),</td></tr>
<tr><td class="line-number">358</td><td class="line-text">					op_source = <span class="hljs-number">1</span>,</td></tr>
<tr><td class="line-number">359</td><td class="line-text">					set_AF_OF_arith(),</td></tr>
<tr><td class="line-number">360</td><td class="line-text">					set_OF(op_dest + <span class="hljs-number">1</span> - i_reg == <span class="hljs-number">1</span> &lt;&lt; (TOP_BIT - <span class="hljs-number">1</span>)),</td></tr>
<tr><td class="line-number">361</td><td class="line-text">					(xlat_opcode_id == <span class="hljs-number">5</span>) &amp;&amp; (set_opcode(<span class="hljs-number">0x10</span>), <span class="hljs-number">0</span>); <span class="hljs-comment">// Decode like ADC</span></td></tr>
<tr><td class="line-number">362</td><td class="line-text">				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i_reg != <span class="hljs-number">6</span>) <span class="hljs-comment">// JMP|CALL</span></td></tr>
<tr><td class="line-number">363</td><td class="line-text">					i_reg - <span class="hljs-number">3</span> || R_M_PUSH(regs16[REG_CS]), <span class="hljs-comment">// CALL (far)</span></td></tr>
<tr><td class="line-number">364</td><td class="line-text">					i_reg &amp; <span class="hljs-number">2</span> &amp;&amp; R_M_PUSH(reg_ip + <span class="hljs-number">2</span> + i_mod*(i_mod != <span class="hljs-number">3</span>) + <span class="hljs-number">2</span>*(!i_mod &amp;&amp; i_rm == <span class="hljs-number">6</span>)), <span class="hljs-comment">// CALL (near or far)</span></td></tr>
<tr><td class="line-number">365</td><td class="line-text">					i_reg &amp; <span class="hljs-number">1</span> &amp;&amp; (regs16[REG_CS] = CAST(<span class="hljs-keyword">short</span>)mem[op_from_addr + <span class="hljs-number">2</span>]), <span class="hljs-comment">// JMP|CALL (far)</span></td></tr>
<tr><td class="line-number">366</td><td class="line-text">					R_M_OP(reg_ip, =, mem[op_from_addr]),</td></tr>
<tr><td class="line-number">367</td><td class="line-text">					set_opcode(<span class="hljs-number">0x9A</span>); <span class="hljs-comment">// Decode like CALL</span></td></tr>
<tr><td class="line-number">368</td><td class="line-text">				<span class="hljs-keyword">else</span> <span class="hljs-comment">// PUSH</span></td></tr>
<tr><td class="line-number">369</td><td class="line-text">					R_M_PUSH(mem[rm_addr])</td></tr>
<tr><td class="line-number">370</td><td class="line-text">			OPCODE <span class="hljs-number">6</span>: <span class="hljs-comment">// TEST r/m, imm16 / NOT|NEG|MUL|IMUL|DIV|IDIV reg</span></td></tr>
<tr><td class="line-number">371</td><td class="line-text">				op_to_addr = op_from_addr;</td></tr>
<tr><td class="line-number">372</td><td class="line-text"></td></tr>
<tr><td class="line-number">373</td><td class="line-text">				<span class="hljs-keyword">switch</span> (i_reg)</td></tr>
<tr><td class="line-number">374</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">375</td><td class="line-text">					OPCODE_CHAIN <span class="hljs-number">0</span>: <span class="hljs-comment">// TEST</span></td></tr>
<tr><td class="line-number">376</td><td class="line-text">						set_opcode(<span class="hljs-number">0x20</span>); <span class="hljs-comment">// Decode like AND</span></td></tr>
<tr><td class="line-number">377</td><td class="line-text">						reg_ip += i_w + <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">378</td><td class="line-text">						R_M_OP(mem[op_to_addr], &amp;, i_data2)</td></tr>
<tr><td class="line-number">379</td><td class="line-text">					OPCODE <span class="hljs-number">2</span>: <span class="hljs-comment">// NOT</span></td></tr>
<tr><td class="line-number">380</td><td class="line-text">						OP(=~)</td></tr>
<tr><td class="line-number">381</td><td class="line-text">					OPCODE <span class="hljs-number">3</span>: <span class="hljs-comment">// NEG</span></td></tr>
<tr><td class="line-number">382</td><td class="line-text">						OP(=-);</td></tr>
<tr><td class="line-number">383</td><td class="line-text">						op_dest = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">384</td><td class="line-text">						set_opcode(<span class="hljs-number">0x28</span>); <span class="hljs-comment">// Decode like SUB</span></td></tr>
<tr><td class="line-number">385</td><td class="line-text">						set_CF(op_result &gt; op_dest)</td></tr>
<tr><td class="line-number">386</td><td class="line-text">					OPCODE <span class="hljs-number">4</span>: <span class="hljs-comment">// MUL</span></td></tr>
<tr><td class="line-number">387</td><td class="line-text">						i_w ? MUL_MACRO(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>, regs16) : MUL_MACRO(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, regs8)</td></tr>
<tr><td class="line-number">388</td><td class="line-text">					OPCODE <span class="hljs-number">5</span>: <span class="hljs-comment">// IMUL</span></td></tr>
<tr><td class="line-number">389</td><td class="line-text">						i_w ? MUL_MACRO(<span class="hljs-keyword">short</span>, regs16) : MUL_MACRO(<span class="hljs-keyword">char</span>, regs8)</td></tr>
<tr><td class="line-number">390</td><td class="line-text">					OPCODE <span class="hljs-number">6</span>: <span class="hljs-comment">// DIV</span></td></tr>
<tr><td class="line-number">391</td><td class="line-text">						i_w ? DIV_MACRO(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>, <span class="hljs-keyword">unsigned</span>, regs16) : DIV_MACRO(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>, regs8)</td></tr>
<tr><td class="line-number">392</td><td class="line-text">					OPCODE <span class="hljs-number">7</span>: <span class="hljs-comment">// IDIV</span></td></tr>
<tr><td class="line-number">393</td><td class="line-text">						i_w ? DIV_MACRO(<span class="hljs-keyword">short</span>, <span class="hljs-keyword">int</span>, regs16) : DIV_MACRO(<span class="hljs-keyword">char</span>, <span class="hljs-keyword">short</span>, regs8);</td></tr>
<tr><td class="line-number">394</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">395</td><td class="line-text">			OPCODE <span class="hljs-number">7</span>: <span class="hljs-comment">// ADD|OR|ADC|SBB|AND|SUB|XOR|CMP AL/AX, immed</span></td></tr>
<tr><td class="line-number">396</td><td class="line-text">				rm_addr = REGS_BASE;</td></tr>
<tr><td class="line-number">397</td><td class="line-text">				i_data2 = i_data0;</td></tr>
<tr><td class="line-number">398</td><td class="line-text">				i_mod = <span class="hljs-number">3</span>;</td></tr>
<tr><td class="line-number">399</td><td class="line-text">				i_reg = extra;</td></tr>
<tr><td class="line-number">400</td><td class="line-text">				reg_ip--;</td></tr>
<tr><td class="line-number">401</td><td class="line-text">			OPCODE_CHAIN <span class="hljs-number">8</span>: <span class="hljs-comment">// ADD|OR|ADC|SBB|AND|SUB|XOR|CMP reg, immed</span></td></tr>
<tr><td class="line-number">402</td><td class="line-text">				op_to_addr = rm_addr;</td></tr>
<tr><td class="line-number">403</td><td class="line-text">				regs16[REG_SCRATCH] = (i_d |= !i_w) ? (<span class="hljs-keyword">char</span>)i_data2 : i_data2;</td></tr>
<tr><td class="line-number">404</td><td class="line-text">				op_from_addr = REGS_BASE + <span class="hljs-number">2</span> * REG_SCRATCH;</td></tr>
<tr><td class="line-number">405</td><td class="line-text">				reg_ip += !i_d + <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">406</td><td class="line-text">				set_opcode(<span class="hljs-number">0x08</span> * (extra = i_reg));</td></tr>
<tr><td class="line-number">407</td><td class="line-text">			OPCODE_CHAIN <span class="hljs-number">9</span>: <span class="hljs-comment">// ADD|OR|ADC|SBB|AND|SUB|XOR|CMP|MOV reg, r/m</span></td></tr>
<tr><td class="line-number">408</td><td class="line-text">				<span class="hljs-keyword">switch</span> (extra)</td></tr>
<tr><td class="line-number">409</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">410</td><td class="line-text">					OPCODE_CHAIN <span class="hljs-number">0</span>: <span class="hljs-comment">// ADD</span></td></tr>
<tr><td class="line-number">411</td><td class="line-text">						OP(+=),</td></tr>
<tr><td class="line-number">412</td><td class="line-text">						set_CF(op_result &lt; op_dest)</td></tr>
<tr><td class="line-number">413</td><td class="line-text">					OPCODE <span class="hljs-number">1</span>: <span class="hljs-comment">// OR</span></td></tr>
<tr><td class="line-number">414</td><td class="line-text">						OP(|=)</td></tr>
<tr><td class="line-number">415</td><td class="line-text">					OPCODE <span class="hljs-number">2</span>: <span class="hljs-comment">// ADC</span></td></tr>
<tr><td class="line-number">416</td><td class="line-text">						ADC_SBB_MACRO(+)</td></tr>
<tr><td class="line-number">417</td><td class="line-text">					OPCODE <span class="hljs-number">3</span>: <span class="hljs-comment">// SBB</span></td></tr>
<tr><td class="line-number">418</td><td class="line-text">						ADC_SBB_MACRO(-)</td></tr>
<tr><td class="line-number">419</td><td class="line-text">					OPCODE <span class="hljs-number">4</span>: <span class="hljs-comment">// AND</span></td></tr>
<tr><td class="line-number">420</td><td class="line-text">						OP(&amp;=)</td></tr>
<tr><td class="line-number">421</td><td class="line-text">					OPCODE <span class="hljs-number">5</span>: <span class="hljs-comment">// SUB</span></td></tr>
<tr><td class="line-number">422</td><td class="line-text">						OP(-=),</td></tr>
<tr><td class="line-number">423</td><td class="line-text">						set_CF(op_result &gt; op_dest)</td></tr>
<tr><td class="line-number">424</td><td class="line-text">					OPCODE <span class="hljs-number">6</span>: <span class="hljs-comment">// XOR</span></td></tr>
<tr><td class="line-number">425</td><td class="line-text">						OP(^=)</td></tr>
<tr><td class="line-number">426</td><td class="line-text">					OPCODE <span class="hljs-number">7</span>: <span class="hljs-comment">// CMP</span></td></tr>
<tr><td class="line-number">427</td><td class="line-text">						OP(-),</td></tr>
<tr><td class="line-number">428</td><td class="line-text">						set_CF(op_result &gt; op_dest)</td></tr>
<tr><td class="line-number">429</td><td class="line-text">					OPCODE <span class="hljs-number">8</span>: <span class="hljs-comment">// MOV</span></td></tr>
<tr><td class="line-number">430</td><td class="line-text">						OP(=);</td></tr>
<tr><td class="line-number">431</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">432</td><td class="line-text">			OPCODE <span class="hljs-number">10</span>: <span class="hljs-comment">// MOV sreg, r/m | POP r/m | LEA reg, r/m</span></td></tr>
<tr><td class="line-number">433</td><td class="line-text">				<span class="hljs-keyword">if</span> (!i_w) <span class="hljs-comment">// MOV</span></td></tr>
<tr><td class="line-number">434</td><td class="line-text">					i_w = <span class="hljs-number">1</span>,</td></tr>
<tr><td class="line-number">435</td><td class="line-text">					i_reg += <span class="hljs-number">8</span>,</td></tr>
<tr><td class="line-number">436</td><td class="line-text">					DECODE_RM_REG,</td></tr>
<tr><td class="line-number">437</td><td class="line-text">					OP(=);</td></tr>
<tr><td class="line-number">438</td><td class="line-text">				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!i_d) <span class="hljs-comment">// LEA</span></td></tr>
<tr><td class="line-number">439</td><td class="line-text">					seg_override_en = <span class="hljs-number">1</span>,</td></tr>
<tr><td class="line-number">440</td><td class="line-text">					seg_override = REG_ZERO,</td></tr>
<tr><td class="line-number">441</td><td class="line-text">					DECODE_RM_REG,</td></tr>
<tr><td class="line-number">442</td><td class="line-text">					R_M_OP(mem[op_from_addr], =, rm_addr);</td></tr>
<tr><td class="line-number">443</td><td class="line-text">				<span class="hljs-keyword">else</span> <span class="hljs-comment">// POP</span></td></tr>
<tr><td class="line-number">444</td><td class="line-text">					R_M_POP(mem[rm_addr])</td></tr>
<tr><td class="line-number">445</td><td class="line-text">			OPCODE <span class="hljs-number">11</span>: <span class="hljs-comment">// MOV AL/AX, [loc]</span></td></tr>
<tr><td class="line-number">446</td><td class="line-text">				i_mod = i_reg = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">447</td><td class="line-text">				i_rm = <span class="hljs-number">6</span>;</td></tr>
<tr><td class="line-number">448</td><td class="line-text">				i_data1 = i_data0;</td></tr>
<tr><td class="line-number">449</td><td class="line-text">				DECODE_RM_REG;</td></tr>
<tr><td class="line-number">450</td><td class="line-text">				MEM_OP(op_from_addr, =, op_to_addr)</td></tr>
<tr><td class="line-number">451</td><td class="line-text">			OPCODE <span class="hljs-number">12</span>: <span class="hljs-comment">// ROL|ROR|RCL|RCR|SHL|SHR|???|SAR reg/mem, 1/CL/imm (80186)</span></td></tr>
<tr><td class="line-number">452</td><td class="line-text">				scratch2_uint = SIGN_OF(mem[rm_addr]),</td></tr>
<tr><td class="line-number">453</td><td class="line-text">				scratch_uint = extra ? <span class="hljs-comment">// xxx reg/mem, imm</span></td></tr>
<tr><td class="line-number">454</td><td class="line-text">					++reg_ip,</td></tr>
<tr><td class="line-number">455</td><td class="line-text">					(<span class="hljs-keyword">char</span>)i_data1</td></tr>
<tr><td class="line-number">456</td><td class="line-text">				: <span class="hljs-comment">// xxx reg/mem, CL</span></td></tr>
<tr><td class="line-number">457</td><td class="line-text">					i_d</td></tr>
<tr><td class="line-number">458</td><td class="line-text">						? <span class="hljs-number">31</span> &amp; regs8[REG_CL]</td></tr>
<tr><td class="line-number">459</td><td class="line-text">				: <span class="hljs-comment">// xxx reg/mem, 1</span></td></tr>
<tr><td class="line-number">460</td><td class="line-text">					<span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">461</td><td class="line-text">				<span class="hljs-keyword">if</span> (scratch_uint)</td></tr>
<tr><td class="line-number">462</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">463</td><td class="line-text">					<span class="hljs-keyword">if</span> (i_reg &lt; <span class="hljs-number">4</span>) <span class="hljs-comment">// Rotate operations</span></td></tr>
<tr><td class="line-number">464</td><td class="line-text">						scratch_uint %= i_reg / <span class="hljs-number">2</span> + TOP_BIT,</td></tr>
<tr><td class="line-number">465</td><td class="line-text">						R_M_OP(scratch2_uint, =, mem[rm_addr]);</td></tr>
<tr><td class="line-number">466</td><td class="line-text">					<span class="hljs-keyword">if</span> (i_reg &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// Rotate/shift right operations</span></td></tr>
<tr><td class="line-number">467</td><td class="line-text">						R_M_OP(mem[rm_addr], &gt;&gt;=, scratch_uint);</td></tr>
<tr><td class="line-number">468</td><td class="line-text">					<span class="hljs-keyword">else</span> <span class="hljs-comment">// Rotate/shift left operations</span></td></tr>
<tr><td class="line-number">469</td><td class="line-text">						R_M_OP(mem[rm_addr], &lt;&lt;=, scratch_uint);</td></tr>
<tr><td class="line-number">470</td><td class="line-text">					<span class="hljs-keyword">if</span> (i_reg &gt; <span class="hljs-number">3</span>) <span class="hljs-comment">// Shift operations</span></td></tr>
<tr><td class="line-number">471</td><td class="line-text">						set_opcode(<span class="hljs-number">0x10</span>); <span class="hljs-comment">// Decode like ADC</span></td></tr>
<tr><td class="line-number">472</td><td class="line-text">					<span class="hljs-keyword">if</span> (i_reg &gt; <span class="hljs-number">4</span>) <span class="hljs-comment">// SHR or SAR</span></td></tr>
<tr><td class="line-number">473</td><td class="line-text">						set_CF(op_dest &gt;&gt; (scratch_uint - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>);</td></tr>
<tr><td class="line-number">474</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">475</td><td class="line-text"></td></tr>
<tr><td class="line-number">476</td><td class="line-text">				<span class="hljs-keyword">switch</span> (i_reg)</td></tr>
<tr><td class="line-number">477</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">478</td><td class="line-text">					OPCODE_CHAIN <span class="hljs-number">0</span>: <span class="hljs-comment">// ROL</span></td></tr>
<tr><td class="line-number">479</td><td class="line-text">						R_M_OP(mem[rm_addr], += , scratch2_uint &gt;&gt; (TOP_BIT - scratch_uint));</td></tr>
<tr><td class="line-number">480</td><td class="line-text">						set_OF(SIGN_OF(op_result) ^ set_CF(op_result &amp; <span class="hljs-number">1</span>))</td></tr>
<tr><td class="line-number">481</td><td class="line-text">					OPCODE <span class="hljs-number">1</span>: <span class="hljs-comment">// ROR</span></td></tr>
<tr><td class="line-number">482</td><td class="line-text">						scratch2_uint &amp;= (<span class="hljs-number">1</span> &lt;&lt; scratch_uint) - <span class="hljs-number">1</span>,</td></tr>
<tr><td class="line-number">483</td><td class="line-text">						R_M_OP(mem[rm_addr], += , scratch2_uint &lt;&lt; (TOP_BIT - scratch_uint));</td></tr>
<tr><td class="line-number">484</td><td class="line-text">						set_OF(SIGN_OF(op_result * <span class="hljs-number">2</span>) ^ set_CF(SIGN_OF(op_result)))</td></tr>
<tr><td class="line-number">485</td><td class="line-text">					OPCODE <span class="hljs-number">2</span>: <span class="hljs-comment">// RCL</span></td></tr>
<tr><td class="line-number">486</td><td class="line-text">						R_M_OP(mem[rm_addr], += (regs8[FLAG_CF] &lt;&lt; (scratch_uint - <span class="hljs-number">1</span>)) + , scratch2_uint &gt;&gt; (<span class="hljs-number">1</span> + TOP_BIT - scratch_uint));</td></tr>
<tr><td class="line-number">487</td><td class="line-text">						set_OF(SIGN_OF(op_result) ^ set_CF(scratch2_uint &amp; <span class="hljs-number">1</span> &lt;&lt; (TOP_BIT - scratch_uint)))</td></tr>
<tr><td class="line-number">488</td><td class="line-text">					OPCODE <span class="hljs-number">3</span>: <span class="hljs-comment">// RCR</span></td></tr>
<tr><td class="line-number">489</td><td class="line-text">						R_M_OP(mem[rm_addr], += (regs8[FLAG_CF] &lt;&lt; (TOP_BIT - scratch_uint)) + , scratch2_uint &lt;&lt; (<span class="hljs-number">1</span> + TOP_BIT - scratch_uint));</td></tr>
<tr><td class="line-number">490</td><td class="line-text">						set_CF(scratch2_uint &amp; <span class="hljs-number">1</span> &lt;&lt; (scratch_uint - <span class="hljs-number">1</span>));</td></tr>
<tr><td class="line-number">491</td><td class="line-text">						set_OF(SIGN_OF(op_result) ^ SIGN_OF(op_result * <span class="hljs-number">2</span>))</td></tr>
<tr><td class="line-number">492</td><td class="line-text">					OPCODE <span class="hljs-number">4</span>: <span class="hljs-comment">// SHL</span></td></tr>
<tr><td class="line-number">493</td><td class="line-text">						set_OF(SIGN_OF(op_result) ^ set_CF(SIGN_OF(op_dest &lt;&lt; (scratch_uint - <span class="hljs-number">1</span>))))</td></tr>
<tr><td class="line-number">494</td><td class="line-text">					OPCODE <span class="hljs-number">5</span>: <span class="hljs-comment">// SHR</span></td></tr>
<tr><td class="line-number">495</td><td class="line-text">						set_OF(SIGN_OF(op_dest))</td></tr>
<tr><td class="line-number">496</td><td class="line-text">					OPCODE <span class="hljs-number">7</span>: <span class="hljs-comment">// SAR</span></td></tr>
<tr><td class="line-number">497</td><td class="line-text">						scratch_uint &lt; TOP_BIT || set_CF(scratch2_uint);</td></tr>
<tr><td class="line-number">498</td><td class="line-text">						set_OF(<span class="hljs-number">0</span>);</td></tr>
<tr><td class="line-number">499</td><td class="line-text">						R_M_OP(mem[rm_addr], +=, scratch2_uint *= ~(((<span class="hljs-number">1</span> &lt;&lt; TOP_BIT) - <span class="hljs-number">1</span>) &gt;&gt; scratch_uint));</td></tr>
<tr><td class="line-number">500</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">501</td><td class="line-text">			OPCODE <span class="hljs-number">13</span>: <span class="hljs-comment">// LOOPxx|JCZX</span></td></tr>
<tr><td class="line-number">502</td><td class="line-text">				scratch_uint = !!--regs16[REG_CX];</td></tr>
<tr><td class="line-number">503</td><td class="line-text"></td></tr>
<tr><td class="line-number">504</td><td class="line-text">				<span class="hljs-keyword">switch</span>(i_reg4bit)</td></tr>
<tr><td class="line-number">505</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">506</td><td class="line-text">					OPCODE_CHAIN <span class="hljs-number">0</span>: <span class="hljs-comment">// LOOPNZ</span></td></tr>
<tr><td class="line-number">507</td><td class="line-text">						scratch_uint &amp;= !regs8[FLAG_ZF]</td></tr>
<tr><td class="line-number">508</td><td class="line-text">					OPCODE <span class="hljs-number">1</span>: <span class="hljs-comment">// LOOPZ</span></td></tr>
<tr><td class="line-number">509</td><td class="line-text">						scratch_uint &amp;= regs8[FLAG_ZF]</td></tr>
<tr><td class="line-number">510</td><td class="line-text">					OPCODE <span class="hljs-number">3</span>: <span class="hljs-comment">// JCXXZ</span></td></tr>
<tr><td class="line-number">511</td><td class="line-text">						scratch_uint = !++regs16[REG_CX];</td></tr>
<tr><td class="line-number">512</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">513</td><td class="line-text">				reg_ip += scratch_uint*(<span class="hljs-keyword">char</span>)i_data0</td></tr>
<tr><td class="line-number">514</td><td class="line-text">			OPCODE <span class="hljs-number">14</span>: <span class="hljs-comment">// JMP | CALL short/near</span></td></tr>
<tr><td class="line-number">515</td><td class="line-text">				reg_ip += <span class="hljs-number">3</span> - i_d;</td></tr>
<tr><td class="line-number">516</td><td class="line-text">				<span class="hljs-keyword">if</span> (!i_w)</td></tr>
<tr><td class="line-number">517</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">518</td><td class="line-text">					<span class="hljs-keyword">if</span> (i_d) <span class="hljs-comment">// JMP far</span></td></tr>
<tr><td class="line-number">519</td><td class="line-text">						reg_ip = <span class="hljs-number">0</span>,</td></tr>
<tr><td class="line-number">520</td><td class="line-text">						regs16[REG_CS] = i_data2;</td></tr>
<tr><td class="line-number">521</td><td class="line-text">					<span class="hljs-keyword">else</span> <span class="hljs-comment">// CALL</span></td></tr>
<tr><td class="line-number">522</td><td class="line-text">						R_M_PUSH(reg_ip);</td></tr>
<tr><td class="line-number">523</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">524</td><td class="line-text">				reg_ip += i_d &amp;&amp; i_w ? (<span class="hljs-keyword">char</span>)i_data0 : i_data0</td></tr>
<tr><td class="line-number">525</td><td class="line-text">			OPCODE <span class="hljs-number">15</span>: <span class="hljs-comment">// TEST reg, r/m</span></td></tr>
<tr><td class="line-number">526</td><td class="line-text">				MEM_OP(op_from_addr, &amp;, op_to_addr)</td></tr>
<tr><td class="line-number">527</td><td class="line-text">			OPCODE <span class="hljs-number">16</span>: <span class="hljs-comment">// XCHG AX, regs16</span></td></tr>
<tr><td class="line-number">528</td><td class="line-text">				i_w = <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">529</td><td class="line-text">				op_to_addr = REGS_BASE;</td></tr>
<tr><td class="line-number">530</td><td class="line-text">				op_from_addr = GET_REG_ADDR(i_reg4bit);</td></tr>
<tr><td class="line-number">531</td><td class="line-text">			OPCODE_CHAIN <span class="hljs-number">24</span>: <span class="hljs-comment">// NOP|XCHG reg, r/m</span></td></tr>
<tr><td class="line-number">532</td><td class="line-text">				<span class="hljs-keyword">if</span> (op_to_addr != op_from_addr)</td></tr>
<tr><td class="line-number">533</td><td class="line-text">					OP(^=),</td></tr>
<tr><td class="line-number">534</td><td class="line-text">					MEM_OP(op_from_addr, ^=, op_to_addr),</td></tr>
<tr><td class="line-number">535</td><td class="line-text">					OP(^=)</td></tr>
<tr><td class="line-number">536</td><td class="line-text">			OPCODE <span class="hljs-number">17</span>: <span class="hljs-comment">// MOVSx (extra=0)|STOSx (extra=1)|LODSx (extra=2)</span></td></tr>
<tr><td class="line-number">537</td><td class="line-text">				scratch2_uint = seg_override_en ? seg_override : REG_DS;</td></tr>
<tr><td class="line-number">538</td><td class="line-text"></td></tr>
<tr><td class="line-number">539</td><td class="line-text">				<span class="hljs-keyword">for</span> (scratch_uint = rep_override_en ? regs16[REG_CX] : <span class="hljs-number">1</span>; scratch_uint; scratch_uint--)</td></tr>
<tr><td class="line-number">540</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">541</td><td class="line-text">					MEM_OP(extra &lt; <span class="hljs-number">2</span> ? SEGREG(REG_ES, REG_DI,) : REGS_BASE, =, extra &amp; <span class="hljs-number">1</span> ? REGS_BASE : SEGREG(scratch2_uint, REG_SI,)),</td></tr>
<tr><td class="line-number">542</td><td class="line-text">					extra &amp; <span class="hljs-number">1</span> || INDEX_INC(REG_SI),</td></tr>
<tr><td class="line-number">543</td><td class="line-text">					extra &amp; <span class="hljs-number">2</span> || INDEX_INC(REG_DI);</td></tr>
<tr><td class="line-number">544</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">545</td><td class="line-text"></td></tr>
<tr><td class="line-number">546</td><td class="line-text">				<span class="hljs-keyword">if</span> (rep_override_en)</td></tr>
<tr><td class="line-number">547</td><td class="line-text">					regs16[REG_CX] = <span class="hljs-number">0</span></td></tr>
<tr><td class="line-number">548</td><td class="line-text">			OPCODE <span class="hljs-number">18</span>: <span class="hljs-comment">// CMPSx (extra=0)|SCASx (extra=1)</span></td></tr>
<tr><td class="line-number">549</td><td class="line-text">				scratch2_uint = seg_override_en ? seg_override : REG_DS;</td></tr>
<tr><td class="line-number">550</td><td class="line-text"></td></tr>
<tr><td class="line-number">551</td><td class="line-text">				<span class="hljs-keyword">if</span> ((scratch_uint = rep_override_en ? regs16[REG_CX] : <span class="hljs-number">1</span>))</td></tr>
<tr><td class="line-number">552</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">553</td><td class="line-text">					<span class="hljs-keyword">for</span> (; scratch_uint; rep_override_en || scratch_uint--)</td></tr>
<tr><td class="line-number">554</td><td class="line-text">					{</td></tr>
<tr><td class="line-number">555</td><td class="line-text">						MEM_OP(extra ? REGS_BASE : SEGREG(scratch2_uint, REG_SI,), -, SEGREG(REG_ES, REG_DI,)),</td></tr>
<tr><td class="line-number">556</td><td class="line-text">						extra || INDEX_INC(REG_SI),</td></tr>
<tr><td class="line-number">557</td><td class="line-text">						
INDEX_INC(REG_DI), rep_override_en &amp;&amp; !(--regs16[REG_CX] 
&amp;&amp; (!op_result == rep_mode)) &amp;&amp; (scratch_uint = <span class="hljs-number">0</span>);</td></tr>
<tr><td class="line-number">558</td><td class="line-text">					}</td></tr>
<tr><td class="line-number">559</td><td class="line-text"></td></tr>
<tr><td class="line-number">560</td><td class="line-text">					set_flags_type = FLAGS_UPDATE_SZP | FLAGS_UPDATE_AO_ARITH; <span class="hljs-comment">// Funge to set SZP/AO flags</span></td></tr>
<tr><td class="line-number">561</td><td class="line-text">					set_CF(op_result &gt; op_dest);</td></tr>
<tr><td class="line-number">562</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">563</td><td class="line-text">			OPCODE <span class="hljs-number">19</span>: <span class="hljs-comment">// RET|RETF|IRET</span></td></tr>
<tr><td class="line-number">564</td><td class="line-text">				i_d = i_w;</td></tr>
<tr><td class="line-number">565</td><td class="line-text">				R_M_POP(reg_ip);</td></tr>
<tr><td class="line-number">566</td><td class="line-text">				<span class="hljs-keyword">if</span> (extra) <span class="hljs-comment">// IRET|RETF|RETF imm16</span></td></tr>
<tr><td class="line-number">567</td><td class="line-text">					R_M_POP(regs16[REG_CS]);</td></tr>
<tr><td class="line-number">568</td><td class="line-text">				<span class="hljs-keyword">if</span> (extra &amp; <span class="hljs-number">2</span>) <span class="hljs-comment">// IRET</span></td></tr>
<tr><td class="line-number">569</td><td class="line-text">					set_flags(R_M_POP(scratch_uint));</td></tr>
<tr><td class="line-number">570</td><td class="line-text">				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!i_d) <span class="hljs-comment">// RET|RETF imm16</span></td></tr>
<tr><td class="line-number">571</td><td class="line-text">					regs16[REG_SP] += i_data0</td></tr>
<tr><td class="line-number">572</td><td class="line-text">			OPCODE <span class="hljs-number">20</span>: <span class="hljs-comment">// MOV r/m, immed</span></td></tr>
<tr><td class="line-number">573</td><td class="line-text">				R_M_OP(mem[op_from_addr], =, i_data2)</td></tr>
<tr><td class="line-number">574</td><td class="line-text">			OPCODE <span class="hljs-number">21</span>: <span class="hljs-comment">// IN AL/AX, DX/imm8</span></td></tr>
<tr><td class="line-number">575</td><td class="line-text">				io_ports[<span class="hljs-number">0x20</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// PIC EOI</span></td></tr>
<tr><td class="line-number">576</td><td class="line-text">				io_ports[<span class="hljs-number">0x42</span>] = --io_ports[<span class="hljs-number">0x40</span>]; <span class="hljs-comment">// PIT channel 0/2 read placeholder</span></td></tr>
<tr><td class="line-number">577</td><td class="line-text">				io_ports[<span class="hljs-number">0x3DA</span>] ^= <span class="hljs-number">9</span>; <span class="hljs-comment">// CGA refresh</span></td></tr>
<tr><td class="line-number">578</td><td class="line-text">				scratch_uint = extra ? regs16[REG_DX] : (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)i_data0;</td></tr>
<tr><td class="line-number">579</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x60</span> &amp;&amp; (io_ports[<span class="hljs-number">0x64</span>] = <span class="hljs-number">0</span>); <span class="hljs-comment">// Scancode read flag</span></td></tr>
<tr><td class="line-number">580</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x3D5</span> &amp;&amp; (io_ports[<span class="hljs-number">0x3D4</span>] &gt;&gt; <span class="hljs-number">1</span> == <span class="hljs-number">7</span>) &amp;&amp; (io_ports[<span class="hljs-number">0x3D5</span>] = ((mem[<span class="hljs-number">0x49E</span>]*<span class="hljs-number">80</span> + mem[<span class="hljs-number">0x49D</span>] + CAST(<span class="hljs-keyword">short</span>)mem[<span class="hljs-number">0x4AD</span>]) &amp; (io_ports[<span class="hljs-number">0x3D4</span>] &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">0xFF</span> : <span class="hljs-number">0xFF00</span>)) &gt;&gt; (io_ports[<span class="hljs-number">0x3D4</span>] &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">8</span>)); <span class="hljs-comment">// CRT cursor position</span></td></tr>
<tr><td class="line-number">581</td><td class="line-text">				R_M_OP(regs8[REG_AL], =, io_ports[scratch_uint]);</td></tr>
<tr><td class="line-number">582</td><td class="line-text">			OPCODE <span class="hljs-number">22</span>: <span class="hljs-comment">// OUT DX/imm8, AL/AX</span></td></tr>
<tr><td class="line-number">583</td><td class="line-text">				scratch_uint = extra ? regs16[REG_DX] : (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)i_data0;</td></tr>
<tr><td class="line-number">584</td><td class="line-text">				R_M_OP(io_ports[scratch_uint], =, regs8[REG_AL]);</td></tr>
<tr><td class="line-number">585</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x61</span> &amp;&amp; (io_hi_lo = <span class="hljs-number">0</span>, spkr_en |= regs8[REG_AL] &amp; <span class="hljs-number">3</span>); <span class="hljs-comment">// Speaker control</span></td></tr>
<tr><td class="line-number">586</td><td class="line-text">				(scratch_uint == <span class="hljs-number">0x40</span> || scratch_uint == <span class="hljs-number">0x42</span>) &amp;&amp; (io_ports[<span class="hljs-number">0x43</span>] &amp; <span class="hljs-number">6</span>) &amp;&amp; (mem[<span class="hljs-number">0x469</span> + scratch_uint - (io_hi_lo ^= <span class="hljs-number">1</span>)] = regs8[REG_AL]); <span class="hljs-comment">// PIT rate programming</span></td></tr>
<tr><td class="line-number">587</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">588</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x43</span> &amp;&amp; (io_hi_lo = <span class="hljs-number">0</span>, regs8[REG_AL] &gt;&gt; <span class="hljs-number">6</span> == <span class="hljs-number">2</span>) &amp;&amp; (SDL_PauseAudio((regs8[REG_AL] &amp; <span class="hljs-number">0xF7</span>) != <span class="hljs-number">0xB6</span>), <span class="hljs-number">0</span>); <span class="hljs-comment">// Speaker enable</span></td></tr>
<tr><td class="line-number">589</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">590</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x3D5</span> &amp;&amp; (io_ports[<span class="hljs-number">0x3D4</span>] &gt;&gt; <span class="hljs-number">1</span> == <span class="hljs-number">6</span>) &amp;&amp; (mem[<span class="hljs-number">0x4AD</span> + !(io_ports[<span class="hljs-number">0x3D4</span>] &amp; <span class="hljs-number">1</span>)] = regs8[REG_AL]); <span class="hljs-comment">// CRT video RAM start offset</span></td></tr>
<tr><td class="line-number">591</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x3D5</span> &amp;&amp; (io_ports[<span class="hljs-number">0x3D4</span>] &gt;&gt; <span class="hljs-number">1</span> == <span class="hljs-number">7</span>) &amp;&amp; (scratch2_uint = ((mem[<span class="hljs-number">0x49E</span>]*<span class="hljs-number">80</span> + mem[<span class="hljs-number">0x49D</span>] + CAST(<span class="hljs-keyword">short</span>)mem[<span class="hljs-number">0x4AD</span>]) &amp; (io_ports[<span class="hljs-number">0x3D4</span>] &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">0xFF00</span> : <span class="hljs-number">0xFF</span>)) + (regs8[REG_AL] &lt;&lt; (io_ports[<span class="hljs-number">0x3D4</span>] &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">8</span>)) - CAST(<span class="hljs-keyword">short</span>)mem[<span class="hljs-number">0x4AD</span>], mem[<span class="hljs-number">0x49D</span>] = scratch2_uint % <span class="hljs-number">80</span>, mem[<span class="hljs-number">0x49E</span>] = scratch2_uint / <span class="hljs-number">80</span>); <span class="hljs-comment">// CRT cursor position</span></td></tr>
<tr><td class="line-number">592</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x3B5</span> &amp;&amp; io_ports[<span class="hljs-number">0x3B4</span>] == <span class="hljs-number">1</span> &amp;&amp; (GRAPHICS_X = regs8[REG_AL] * <span class="hljs-number">16</span>); <span class="hljs-comment">// Hercules resolution reprogramming. Defaults are set in the BIOS</span></td></tr>
<tr><td class="line-number">593</td><td class="line-text">				scratch_uint == <span class="hljs-number">0x3B5</span> &amp;&amp; io_ports[<span class="hljs-number">0x3B4</span>] == <span class="hljs-number">6</span> &amp;&amp; (GRAPHICS_Y = regs8[REG_AL] * <span class="hljs-number">4</span>);</td></tr>
<tr><td class="line-number">594</td><td class="line-text">			OPCODE <span class="hljs-number">23</span>: <span class="hljs-comment">// REPxx</span></td></tr>
<tr><td class="line-number">595</td><td class="line-text">				rep_override_en = <span class="hljs-number">2</span>;</td></tr>
<tr><td class="line-number">596</td><td class="line-text">				rep_mode = i_w;</td></tr>
<tr><td class="line-number">597</td><td class="line-text">				seg_override_en &amp;&amp; seg_override_en++</td></tr>
<tr><td class="line-number">598</td><td class="line-text">			OPCODE <span class="hljs-number">25</span>: <span class="hljs-comment">// PUSH reg</span></td></tr>
<tr><td class="line-number">599</td><td class="line-text">				R_M_PUSH(regs16[extra])</td></tr>
<tr><td class="line-number">600</td><td class="line-text">			OPCODE <span class="hljs-number">26</span>: <span class="hljs-comment">// POP reg</span></td></tr>
<tr><td class="line-number">601</td><td class="line-text">				R_M_POP(regs16[extra])</td></tr>
<tr><td class="line-number">602</td><td class="line-text">			OPCODE <span class="hljs-number">27</span>: <span class="hljs-comment">// xS: segment overrides</span></td></tr>
<tr><td class="line-number">603</td><td class="line-text">				seg_override_en = <span class="hljs-number">2</span>;</td></tr>
<tr><td class="line-number">604</td><td class="line-text">				seg_override = extra;</td></tr>
<tr><td class="line-number">605</td><td class="line-text">				rep_override_en &amp;&amp; rep_override_en++</td></tr>
<tr><td class="line-number">606</td><td class="line-text">			OPCODE <span class="hljs-number">28</span>: <span class="hljs-comment">// DAA/DAS</span></td></tr>
<tr><td class="line-number">607</td><td class="line-text">				i_w = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">608</td><td class="line-text">				extra ? DAA_DAS(-=, &gt;=, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0x99</span>) : DAA_DAS(+=, &lt;, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x90</span>) <span class="hljs-comment">// extra = 0 for DAA, 1 for DAS</span></td></tr>
<tr><td class="line-number">609</td><td class="line-text">			OPCODE <span class="hljs-number">29</span>: <span class="hljs-comment">// AAA/AAS</span></td></tr>
<tr><td class="line-number">610</td><td class="line-text">				op_result = AAA_AAS(extra - <span class="hljs-number">1</span>)</td></tr>
<tr><td class="line-number">611</td><td class="line-text">			OPCODE <span class="hljs-number">30</span>: <span class="hljs-comment">// CBW</span></td></tr>
<tr><td class="line-number">612</td><td class="line-text">				regs8[REG_AH] = -SIGN_OF(regs8[REG_AL])</td></tr>
<tr><td class="line-number">613</td><td class="line-text">			OPCODE <span class="hljs-number">31</span>: <span class="hljs-comment">// CWD</span></td></tr>
<tr><td class="line-number">614</td><td class="line-text">				regs16[REG_DX] = -SIGN_OF(regs16[REG_AX])</td></tr>
<tr><td class="line-number">615</td><td class="line-text">			OPCODE <span class="hljs-number">32</span>: <span class="hljs-comment">// CALL FAR imm16:imm16</span></td></tr>
<tr><td class="line-number">616</td><td class="line-text">				R_M_PUSH(regs16[REG_CS]);</td></tr>
<tr><td class="line-number">617</td><td class="line-text">				R_M_PUSH(reg_ip + <span class="hljs-number">5</span>);</td></tr>
<tr><td class="line-number">618</td><td class="line-text">				regs16[REG_CS] = i_data2;</td></tr>
<tr><td class="line-number">619</td><td class="line-text">				reg_ip = i_data0</td></tr>
<tr><td class="line-number">620</td><td class="line-text">			OPCODE <span class="hljs-number">33</span>: <span class="hljs-comment">// PUSHF</span></td></tr>
<tr><td class="line-number">621</td><td class="line-text">				make_flags();</td></tr>
<tr><td class="line-number">622</td><td class="line-text">				R_M_PUSH(scratch_uint)</td></tr>
<tr><td class="line-number">623</td><td class="line-text">			OPCODE <span class="hljs-number">34</span>: <span class="hljs-comment">// POPF</span></td></tr>
<tr><td class="line-number">624</td><td class="line-text">				set_flags(R_M_POP(scratch_uint))</td></tr>
<tr><td class="line-number">625</td><td class="line-text">			OPCODE <span class="hljs-number">35</span>: <span class="hljs-comment">// SAHF</span></td></tr>
<tr><td class="line-number">626</td><td class="line-text">				make_flags();</td></tr>
<tr><td class="line-number">627</td><td class="line-text">				set_flags((scratch_uint &amp; <span class="hljs-number">0xFF00</span>) + regs8[REG_AH])</td></tr>
<tr><td class="line-number">628</td><td class="line-text">			OPCODE <span class="hljs-number">36</span>: <span class="hljs-comment">// LAHF</span></td></tr>
<tr><td class="line-number">629</td><td class="line-text">				make_flags(),</td></tr>
<tr><td class="line-number">630</td><td class="line-text">				regs8[REG_AH] = scratch_uint</td></tr>
<tr><td class="line-number">631</td><td class="line-text">			OPCODE <span class="hljs-number">37</span>: <span class="hljs-comment">// LES|LDS reg, r/m</span></td></tr>
<tr><td class="line-number">632</td><td class="line-text">				i_w = i_d = <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">633</td><td class="line-text">				DECODE_RM_REG;</td></tr>
<tr><td class="line-number">634</td><td class="line-text">				OP(=);</td></tr>
<tr><td class="line-number">635</td><td class="line-text">				MEM_OP(REGS_BASE + extra, =, rm_addr + <span class="hljs-number">2</span>)</td></tr>
<tr><td class="line-number">636</td><td class="line-text">			OPCODE <span class="hljs-number">38</span>: <span class="hljs-comment">// INT 3</span></td></tr>
<tr><td class="line-number">637</td><td class="line-text">				++reg_ip;</td></tr>
<tr><td class="line-number">638</td><td class="line-text">				pc_interrupt(<span class="hljs-number">3</span>)</td></tr>
<tr><td class="line-number">639</td><td class="line-text">			OPCODE <span class="hljs-number">39</span>: <span class="hljs-comment">// INT imm8</span></td></tr>
<tr><td class="line-number">640</td><td class="line-text">				reg_ip += <span class="hljs-number">2</span>;</td></tr>
<tr><td class="line-number">641</td><td class="line-text">				pc_interrupt(i_data0)</td></tr>
<tr><td class="line-number">642</td><td class="line-text">			OPCODE <span class="hljs-number">40</span>: <span class="hljs-comment">// INTO</span></td></tr>
<tr><td class="line-number">643</td><td class="line-text">				++reg_ip;</td></tr>
<tr><td class="line-number">644</td><td class="line-text">				regs8[FLAG_OF] &amp;&amp; pc_interrupt(<span class="hljs-number">4</span>)</td></tr>
<tr><td class="line-number">645</td><td class="line-text">			OPCODE <span class="hljs-number">41</span>: <span class="hljs-comment">// AAM</span></td></tr>
<tr><td class="line-number">646</td><td class="line-text">				<span class="hljs-keyword">if</span> (i_data0 &amp;= <span class="hljs-number">0xFF</span>)</td></tr>
<tr><td class="line-number">647</td><td class="line-text">					regs8[REG_AH] = regs8[REG_AL] / i_data0,</td></tr>
<tr><td class="line-number">648</td><td class="line-text">					op_result = regs8[REG_AL] %= i_data0;</td></tr>
<tr><td class="line-number">649</td><td class="line-text">				<span class="hljs-keyword">else</span> <span class="hljs-comment">// Divide by zero</span></td></tr>
<tr><td class="line-number">650</td><td class="line-text">					pc_interrupt(<span class="hljs-number">0</span>)</td></tr>
<tr><td class="line-number">651</td><td class="line-text">			OPCODE <span class="hljs-number">42</span>: <span class="hljs-comment">// AAD</span></td></tr>
<tr><td class="line-number">652</td><td class="line-text">				i_w = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">653</td><td class="line-text">				regs16[REG_AX] = op_result = <span class="hljs-number">0xFF</span> &amp; regs8[REG_AL] + i_data0 * regs8[REG_AH]</td></tr>
<tr><td class="line-number">654</td><td class="line-text">			OPCODE <span class="hljs-number">43</span>: <span class="hljs-comment">// SALC</span></td></tr>
<tr><td class="line-number">655</td><td class="line-text">				regs8[REG_AL] = -regs8[FLAG_CF]</td></tr>
<tr><td class="line-number">656</td><td class="line-text">			OPCODE <span class="hljs-number">44</span>: <span class="hljs-comment">// XLAT</span></td></tr>
<tr><td class="line-number">657</td><td class="line-text">				regs8[REG_AL] = mem[SEGREG(seg_override_en ? seg_override : REG_DS, REG_BX, regs8[REG_AL] +)]</td></tr>
<tr><td class="line-number">658</td><td class="line-text">			OPCODE <span class="hljs-number">45</span>: <span class="hljs-comment">// CMC</span></td></tr>
<tr><td class="line-number">659</td><td class="line-text">				regs8[FLAG_CF] ^= <span class="hljs-number">1</span></td></tr>
<tr><td class="line-number">660</td><td class="line-text">			OPCODE <span class="hljs-number">46</span>: <span class="hljs-comment">// CLC|STC|CLI|STI|CLD|STD</span></td></tr>
<tr><td class="line-number">661</td><td class="line-text">				regs8[extra / <span class="hljs-number">2</span>] = extra &amp; <span class="hljs-number">1</span></td></tr>
<tr><td class="line-number">662</td><td class="line-text">			OPCODE <span class="hljs-number">47</span>: <span class="hljs-comment">// TEST AL/AX, immed</span></td></tr>
<tr><td class="line-number">663</td><td class="line-text">				R_M_OP(regs8[REG_AL], &amp;, i_data0)</td></tr>
<tr><td class="line-number">664</td><td class="line-text">			OPCODE <span class="hljs-number">48</span>: <span class="hljs-comment">// Emulator-specific 0F xx opcodes</span></td></tr>
<tr><td class="line-number">665</td><td class="line-text">				<span class="hljs-keyword">switch</span> ((<span class="hljs-keyword">char</span>)i_data0)</td></tr>
<tr><td class="line-number">666</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">667</td><td class="line-text">					OPCODE_CHAIN <span class="hljs-number">0</span>: <span class="hljs-comment">// PUTCHAR_AL</span></td></tr>
<tr><td class="line-number">668</td><td class="line-text">						write(<span class="hljs-number">1</span>, regs8, <span class="hljs-number">1</span>)</td></tr>
<tr><td class="line-number">669</td><td class="line-text">					OPCODE <span class="hljs-number">1</span>: <span class="hljs-comment">// GET_RTC</span></td></tr>
<tr><td class="line-number">670</td><td class="line-text">						time(&amp;clock_buf);</td></tr>
<tr><td class="line-number">671</td><td class="line-text">						ftime(&amp;ms_clock);</td></tr>
<tr><td class="line-number">672</td><td class="line-text">						<span class="hljs-built_in">memcpy</span>(mem + SEGREG(REG_ES, REG_BX,), localtime(&amp;clock_buf), <span class="hljs-keyword">sizeof</span>(struct tm));</td></tr>
<tr><td class="line-number">673</td><td class="line-text">						CAST(<span class="hljs-keyword">short</span>)mem[SEGREG(REG_ES, REG_BX, <span class="hljs-number">36</span>+)] = ms_clock.millitm;</td></tr>
<tr><td class="line-number">674</td><td class="line-text">					OPCODE <span class="hljs-number">2</span>: <span class="hljs-comment">// DISK_READ</span></td></tr>
<tr><td class="line-number">675</td><td class="line-text">					OPCODE_CHAIN <span class="hljs-number">3</span>: <span class="hljs-comment">// DISK_WRITE</span></td></tr>
<tr><td class="line-number">676</td><td class="line-text">						regs8[REG_AL] = ~lseek(disk[regs8[REG_DL]], CAST(<span class="hljs-keyword">unsigned</span>)regs16[REG_BP] &lt;&lt; <span class="hljs-number">9</span>, <span class="hljs-number">0</span>)</td></tr>
<tr><td class="line-number">677</td><td class="line-text">							? ((<span class="hljs-keyword">char</span>)i_data0 == <span class="hljs-number">3</span> ? (<span class="hljs-keyword">int</span>(*)())write : (<span class="hljs-keyword">int</span>(*)())read)(disk[regs8[REG_DL]], mem + SEGREG(REG_ES, REG_BX,), regs16[REG_AX])</td></tr>
<tr><td class="line-number">678</td><td class="line-text">							: <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">679</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">680</td><td class="line-text">		}</td></tr>
<tr><td class="line-number">681</td><td class="line-text"></td></tr>
<tr><td class="line-number">682</td><td class="line-text">		<span class="hljs-comment">// Increment instruction pointer by computed instruction length. Tables in the BIOS binary</span></td></tr>
<tr><td class="line-number">683</td><td class="line-text">		<span class="hljs-comment">// help us here.</span></td></tr>
<tr><td class="line-number">684</td><td class="line-text">		reg_ip += (i_mod*(i_mod != <span class="hljs-number">3</span>) + <span class="hljs-number">2</span>*(!i_mod &amp;&amp; i_rm == <span class="hljs-number">6</span>))*i_mod_size
 + bios_table_lookup[TABLE_BASE_INST_SIZE][raw_opcode_id] + 
bios_table_lookup[TABLE_I_W_SIZE][raw_opcode_id]*(i_w + <span class="hljs-number">1</span>);</td></tr>
<tr><td class="line-number">685</td><td class="line-text"></td></tr>
<tr><td class="line-number">686</td><td class="line-text">		<span class="hljs-comment">// If instruction needs to update SF, ZF and PF, set them as appropriate</span></td></tr>
<tr><td class="line-number">687</td><td class="line-text">		<span class="hljs-keyword">if</span> (set_flags_type &amp; FLAGS_UPDATE_SZP)</td></tr>
<tr><td class="line-number">688</td><td class="line-text">		{</td></tr>
<tr><td class="line-number">689</td><td class="line-text">			regs8[FLAG_SF] = SIGN_OF(op_result);</td></tr>
<tr><td class="line-number">690</td><td class="line-text">			regs8[FLAG_ZF] = !op_result;</td></tr>
<tr><td class="line-number">691</td><td class="line-text">			regs8[FLAG_PF] = bios_table_lookup[TABLE_PARITY_FLAG][(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)op_result];</td></tr>
<tr><td class="line-number">692</td><td class="line-text"></td></tr>
<tr><td class="line-number">693</td><td class="line-text">			<span class="hljs-comment">// If instruction is an arithmetic or logic operation, also set AF/OF/CF as appropriate.</span></td></tr>
<tr><td class="line-number">694</td><td class="line-text">			<span class="hljs-keyword">if</span> (set_flags_type &amp; FLAGS_UPDATE_AO_ARITH)</td></tr>
<tr><td class="line-number">695</td><td class="line-text">				set_AF_OF_arith();</td></tr>
<tr><td class="line-number">696</td><td class="line-text">			<span class="hljs-keyword">if</span> (set_flags_type &amp; FLAGS_UPDATE_OC_LOGIC)</td></tr>
<tr><td class="line-number">697</td><td class="line-text">				set_CF(<span class="hljs-number">0</span>), set_OF(<span class="hljs-number">0</span>);</td></tr>
<tr><td class="line-number">698</td><td class="line-text">		}</td></tr>
<tr><td class="line-number">699</td><td class="line-text"></td></tr>
<tr><td class="line-number">700</td><td class="line-text">		<span class="hljs-comment">// Poll timer/keyboard every KEYBOARD_TIMER_UPDATE_DELAY instructions</span></td></tr>
<tr><td class="line-number">701</td><td class="line-text">		<span class="hljs-keyword">if</span> (!(++inst_counter % KEYBOARD_TIMER_UPDATE_DELAY))</td></tr>
<tr><td class="line-number">702</td><td class="line-text">			int8_asap = <span class="hljs-number">1</span>;</td></tr>
<tr><td class="line-number">703</td><td class="line-text"></td></tr>
<tr><td class="line-number">704</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">705</td><td class="line-text">		<span class="hljs-comment">// Update the video graphics display every GRAPHICS_UPDATE_DELAY instructions</span></td></tr>
<tr><td class="line-number">706</td><td class="line-text">		<span class="hljs-keyword">if</span> (!(inst_counter % GRAPHICS_UPDATE_DELAY))</td></tr>
<tr><td class="line-number">707</td><td class="line-text">		{</td></tr>
<tr><td class="line-number">708</td><td class="line-text">			<span class="hljs-comment">// Video card in graphics mode?</span></td></tr>
<tr><td class="line-number">709</td><td class="line-text">			<span class="hljs-keyword">if</span> (io_ports[<span class="hljs-number">0x3B8</span>] &amp; <span class="hljs-number">2</span>)</td></tr>
<tr><td class="line-number">710</td><td class="line-text">			{</td></tr>
<tr><td class="line-number">711</td><td class="line-text">				<span class="hljs-comment">// If we don't already have an SDL window open, set it up and compute color and video memory translation tables</span></td></tr>
<tr><td class="line-number">712</td><td class="line-text">				<span class="hljs-keyword">if</span> (!sdl_screen)</td></tr>
<tr><td class="line-number">713</td><td class="line-text">				{</td></tr>
<tr><td class="line-number">714</td><td class="line-text">					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)</td></tr>
<tr><td class="line-number">715</td><td class="line-text">						pixel_colors[i] = mem[<span class="hljs-number">0x4AC</span>] ? <span class="hljs-comment">// CGA?</span></td></tr>
<tr><td class="line-number">716</td><td class="line-text">							cga_colors[(i &amp; <span class="hljs-number">12</span>) &gt;&gt; <span class="hljs-number">2</span>] + (cga_colors[i &amp; <span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">16</span>) <span class="hljs-comment">// CGA -&gt; RGB332</span></td></tr>
<tr><td class="line-number">717</td><td class="line-text">							: <span class="hljs-number">0xFF</span>*(((i &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">24</span>) + ((i &amp; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">15</span>) + ((i &amp; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">6</span>) + ((i &amp; <span class="hljs-number">8</span>) &gt;&gt; <span class="hljs-number">3</span>)); <span class="hljs-comment">// Hercules -&gt; RGB332</span></td></tr>
<tr><td class="line-number">718</td><td class="line-text"></td></tr>
<tr><td class="line-number">719</td><td class="line-text">					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GRAPHICS_X * GRAPHICS_Y / <span class="hljs-number">4</span>; i++)</td></tr>
<tr><td class="line-number">720</td><td class="line-text">						vid_addr_lookup[i] = i / GRAPHICS_X * (GRAPHICS_X / <span class="hljs-number">8</span>) + (i / <span class="hljs-number">2</span>) % (GRAPHICS_X / <span class="hljs-number">8</span>) + <span class="hljs-number">0x2000</span>*(mem[<span class="hljs-number">0x4AC</span>] ? (<span class="hljs-number">2</span> * i / GRAPHICS_X) % <span class="hljs-number">2</span> : (<span class="hljs-number">4</span> * i / GRAPHICS_X) % <span class="hljs-number">4</span>);</td></tr>
<tr><td class="line-number">721</td><td class="line-text"></td></tr>
<tr><td class="line-number">722</td><td class="line-text">					SDL_Init(SDL_INIT_VIDEO);</td></tr>
<tr><td class="line-number">723</td><td class="line-text">					sdl_screen = SDL_SetVideoMode(GRAPHICS_X, GRAPHICS_Y, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);</td></tr>
<tr><td class="line-number">724</td><td class="line-text">					SDL_EnableUNICODE(<span class="hljs-number">1</span>);</td></tr>
<tr><td class="line-number">725</td><td class="line-text">					SDL_EnableKeyRepeat(<span class="hljs-number">500</span>, <span class="hljs-number">30</span>);</td></tr>
<tr><td class="line-number">726</td><td class="line-text">				}</td></tr>
<tr><td class="line-number">727</td><td class="line-text"></td></tr>
<tr><td class="line-number">728</td><td class="line-text">				<span class="hljs-comment">// Refresh SDL display from emulated graphics card video RAM</span></td></tr>
<tr><td class="line-number">729</td><td class="line-text">				vid_mem_base = mem + <span class="hljs-number">0xB0000</span> + <span class="hljs-number">0x8000</span>*(mem[<span class="hljs-number">0x4AC</span>] ? <span class="hljs-number">1</span> : io_ports[<span class="hljs-number">0x3B8</span>] &gt;&gt; <span class="hljs-number">7</span>); <span class="hljs-comment">// B800:0 for CGA/Hercules bank 2, B000:0 for Hercules bank 1</span></td></tr>
<tr><td class="line-number">730</td><td class="line-text">				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GRAPHICS_X * GRAPHICS_Y / <span class="hljs-number">4</span>; i++)</td></tr>
<tr><td class="line-number">731</td><td class="line-text">					((<span class="hljs-keyword">unsigned</span> *)sdl_screen-&gt;pixels)[i] = pixel_colors[<span class="hljs-number">15</span> &amp; (vid_mem_base[vid_addr_lookup[i]] &gt;&gt; <span class="hljs-number">4</span>*!(i &amp; <span class="hljs-number">1</span>))];</td></tr>
<tr><td class="line-number">732</td><td class="line-text"></td></tr>
<tr><td class="line-number">733</td><td class="line-text">				SDL_Flip(sdl_screen);</td></tr>
<tr><td class="line-number">734</td><td class="line-text">			}</td></tr>
<tr><td class="line-number">735</td><td class="line-text">			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sdl_screen) <span class="hljs-comment">// Application has gone back to text mode, so close the SDL window</span></td></tr>
<tr><td class="line-number">736</td><td class="line-text">			{</td></tr>
<tr><td class="line-number">737</td><td class="line-text">				SDL_QuitSubSystem(SDL_INIT_VIDEO);</td></tr>
<tr><td class="line-number">738</td><td class="line-text">				sdl_screen = <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">739</td><td class="line-text">			}</td></tr>
<tr><td class="line-number">740</td><td class="line-text">			SDL_PumpEvents();</td></tr>
<tr><td class="line-number">741</td><td class="line-text">		}</td></tr>
<tr><td class="line-number">742</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">743</td><td class="line-text"></td></tr>
<tr><td class="line-number">744</td><td class="line-text">		<span class="hljs-comment">// Application has set trap flag, so fire INT 1</span></td></tr>
<tr><td class="line-number">745</td><td class="line-text">		<span class="hljs-keyword">if</span> (trap_flag)</td></tr>
<tr><td class="line-number">746</td><td class="line-text">			pc_interrupt(<span class="hljs-number">1</span>);</td></tr>
<tr><td class="line-number">747</td><td class="line-text"></td></tr>
<tr><td class="line-number">748</td><td class="line-text">		trap_flag = regs8[FLAG_TF];</td></tr>
<tr><td class="line-number">749</td><td class="line-text"></td></tr>
<tr><td class="line-number">750</td><td class="line-text">		<span class="hljs-comment">// If a timer tick is pending, interrupts are enabled, and no overrides/REP are active,</span></td></tr>
<tr><td class="line-number">751</td><td class="line-text">		<span class="hljs-comment">// then process the tick and check for new keystrokes</span></td></tr>
<tr><td class="line-number">752</td><td class="line-text">		<span class="hljs-keyword">if</span> (int8_asap &amp;&amp; !seg_override_en &amp;&amp; !rep_override_en &amp;&amp; regs8[FLAG_IF] &amp;&amp; !regs8[FLAG_TF])</td></tr>
<tr><td class="line-number">753</td><td class="line-text">			pc_interrupt(<span class="hljs-number">0xA</span>), int8_asap = <span class="hljs-number">0</span>, SDL_KEYBOARD_DRIVER;</td></tr>
<tr><td class="line-number">754</td><td class="line-text">	}</td></tr>
<tr><td class="line-number">755</td><td class="line-text"></td></tr>
<tr><td class="line-number">756</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NO_GRAPHICS</span></td></tr>
<tr><td class="line-number">757</td><td class="line-text">	SDL_Quit();</td></tr>
<tr><td class="line-number">758</td><td class="line-text"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></td></tr>
<tr><td class="line-number">759</td><td class="line-text">	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</td></tr>
<tr><td class="line-number">760</td><td class="line-text">}</td></tr>
<tr><td class="line-number">761</td><td class="line-text"></td></tr></tbody></table></body></html>
