     1                                  %include "../includes/startup.inc"
     2                              <1> %ifndef _ASM_BOOTCD_INC_
     3                              <1>      %define   _ASM_BOOTCD_INC_ 1
     4                              <1> 
     5                              <1>      %define   KERNELSTARTCS   0x0070   ; we load the kernel at 0070:0000 the I/O drivers from IO.SYS and IBMBIO.COM
     6                              <1>      %define   KERNELSTARTIP   0x0000   ; this gives us 0070:0000 - 07C0:0000 memory to use for kernel.bin
     7                              <1>      %define   PEMCS           0x3000
     8                              <1>      %define   PEMIP           0x0000
     9                              <1>      %define   PEMSS           0x7000
    10                              <1>      %define   PEMSP           0xFFFE
    11                              <1>      
    12                              <1> STRUC SPECIFICATION_PACKET_STRUC
    13 00000000 ??                  <1>      .packed_size:                 resb      1
    14 00000001 ??                  <1>      .boot_media_type:             resb      1
    15 00000002 ??                  <1>      .drive_number:                resb      1
    16 00000003 ??                  <1>      .controller_index:            resb      1
    17 00000004 ????????            <1>      .logical_block_address:       resd      1
    18 00000008 ????                <1>      .device_specification:        resw      1
    19 0000000A ????                <1>      .buffer_segment:              resw      1
    20 0000000C ????                <1>      .load_segment:                resw      1
    21 0000000E ????                <1>      .virtual_sectors:             resw      1
    22 00000010 ??                  <1>      .cylinder_count:              resb      1
    23 00000011 ??                  <1>      .sector_count:                resb      1
    24 00000012 ??                  <1>      .head_count:                  resb      1
    25                              <1> ENDSTRUC
    26                              <1> 
    27                              <1> %macro SPECIFICATION_PACKET 1
    28                              <1>      %1:  ISTRUC SPECIFICATION_PACKET_STRUC
    29                              <1>           at   SPECIFICATION_PACKET_STRUC.packed_size,                 db        0x13
    30                              <1>           at   SPECIFICATION_PACKET_STRUC.boot_media_type,             db        0
    31                              <1>           at   SPECIFICATION_PACKET_STRUC.drive_number,                db        0
    32                              <1>           at   SPECIFICATION_PACKET_STRUC.controller_index,            db        0
    33                              <1>           at   SPECIFICATION_PACKET_STRUC.logical_block_address,       dd        0
    34                              <1>           at   SPECIFICATION_PACKET_STRUC.device_specification,        dw        0
    35                              <1>           at   SPECIFICATION_PACKET_STRUC.buffer_segment,              dw        0
    36                              <1>           at   SPECIFICATION_PACKET_STRUC.load_segment,                dw        0
    37                              <1>           at   SPECIFICATION_PACKET_STRUC.virtual_sectors,             dw        0
    38                              <1>           at   SPECIFICATION_PACKET_STRUC.cylinder_count,              db        0
    39                              <1>           at   SPECIFICATION_PACKET_STRUC.sector_count,                db        0
    40                              <1>           at   SPECIFICATION_PACKET_STRUC.head_count,                  db        0
    41                              <1>      IEND
    42                              <1>      %define %1.packed_size                 %1+SPECIFICATION_PACKET_STRUC.packed_size
    43                              <1>      %define %1.boot_media_type             %1+SPECIFICATION_PACKET_STRUC.boot_media_type
    44                              <1>      %define %1.drive_number                %1+SPECIFICATION_PACKET_STRUC.drive_number
    45                              <1>      %define %1.controller_index            %1+SPECIFICATION_PACKET_STRUC.controller_index
    46                              <1>      %define %1.logical_block_address       %1+SPECIFICATION_PACKET_STRUC.logical_block_address
    47                              <1>      %define %1.device_specification        %1+SPECIFICATION_PACKET_STRUC.device_specification
    48                              <1>      %define %1.buffer_segment              %1+SPECIFICATION_PACKET_STRUC.buffer_segment
    49                              <1>      %define %1.load_segment                %1+SPECIFICATION_PACKET_STRUC.load_segment
    50                              <1>      %define %1.virtual_sectors             %1+SPECIFICATION_PACKET_STRUC.virtual_sectors
    51                              <1>      %define %1.cylinder_count              %1+SPECIFICATION_PACKET_STRUC.cylinder_count
    52                              <1>      %define %1.sector_count                %1+SPECIFICATION_PACKET_STRUC.sector_count
    53                              <1>      %define %1.head_count                  %1+SPECIFICATION_PACKET_STRUC.head_count
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> STRUC DISK_ADDRESS_PACKET_STRUC
    57 00000000 ??                  <1>      .size:                        resb      1
    58 00000001 ??                  <1>      .reserved:                    resb      1
    59 00000002 ????                <1>      .sectors_to_read:             resw      1
    60 00000004 ????                <1>      .offset:                      resw      1
    61 00000006 ????                <1>      .segment:                     resw      1
    62 00000008 ????????            <1>      .start_absolute_sector:       resd      1
    63 0000000C ????????            <1>      .transfer_buffer_address:     resd      1
    64                              <1> ENDSTRUC
    65                              <1> 
    66                              <1> %macro DISK_ADDRESS_PACKET 3
    67                              <1>      %1:  ISTRUC DISK_ADDRESS_PACKET_STRUC
    68                              <1>           at   DISK_ADDRESS_PACKET_STRUC.size,                        db        16
    69                              <1>           at   DISK_ADDRESS_PACKET_STRUC.reserved,                    db        0
    70                              <1>           at   DISK_ADDRESS_PACKET_STRUC.sectors_to_read,             dw        1
    71                              <1>           at   DISK_ADDRESS_PACKET_STRUC.offset,                      dw        %3
    72                              <1>           at   DISK_ADDRESS_PACKET_STRUC.segment,                     dw        %2
    73                              <1>           at   DISK_ADDRESS_PACKET_STRUC.start_absolute_sector,       dd        16
    74                              <1>           at   DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address,     dd        0
    75                              <1>      IEND
    76                              <1>      %define %1.size                         %1+DISK_ADDRESS_PACKET_STRUC.size
    77                              <1>      %define %1.sectors_to_read              %1+DISK_ADDRESS_PACKET_STRUC.sectors_to_read
    78                              <1>      %define %1.offset                       %1+DISK_ADDRESS_PACKET_STRUC.offset
    79                              <1>      %define %1.segment                      %1+DISK_ADDRESS_PACKET_STRUC.segment
    80                              <1>      %define %1.start_absolute_sector        %1+DISK_ADDRESS_PACKET_STRUC.start_absolute_sector
    81                              <1>      %define %1.transfer_buffer_address      %1+DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %endif
     2                                  
     3                                  ORG 0x7C00
     4                                  BITS 16
     5                                  
     6                                  global Start
     7                                  
     8                                  Start:
     9                                  
    10 00000000 EA[5B01]0000                 jmp     0x0000:FlushCS                 ; force system to run from cs:ip = 0000:7C00 instead of 07C0:0000
    11                                       
    12 00000005 00                           bootdrive:               db 0
    13 00000006 507265737320616E79-          pressAnyKey:             db 'Press any key to reboot...',13,10,0
    13 0000000F 206B657920746F2072-
    13 00000018 65626F6F742E2E2E0D-
    13 00000021 0A00               
    14 00000023 4B45524E454C2E4249-          fileName:                db 'KERNEL.BIN',0
    14 0000002C 4E00               
    15 0000002E 00                           directoryEntrySize:      db   0
    16 0000002F 00000000                     fileSector:              dd   0
    17 00000033 00000000                     fileSize:                dd   0
    18 00000037 00                           fileNameLength:          db   0
    19 00000038 20<rep FFh>                  fileNameEntry:           TIMES 255 db ' '     
    20 00000137 00                           fileEntryNumber:         db   0     
    21                                       SPECIFICATION_PACKET     specificationPacket
    28                              <1>  %1: ISTRUC SPECIFICATION_PACKET_STRUC
    29 00000138 13                  <1>  at SPECIFICATION_PACKET_STRUC.packed_size, db 0x13
    30 00000139 00                  <1>  at SPECIFICATION_PACKET_STRUC.boot_media_type, db 0
    31 0000013A 00                  <1>  at SPECIFICATION_PACKET_STRUC.drive_number, db 0
    32 0000013B 00                  <1>  at SPECIFICATION_PACKET_STRUC.controller_index, db 0
    33 0000013C 00000000            <1>  at SPECIFICATION_PACKET_STRUC.logical_block_address, dd 0
    34 00000140 0000                <1>  at SPECIFICATION_PACKET_STRUC.device_specification, dw 0
    35 00000142 0000                <1>  at SPECIFICATION_PACKET_STRUC.buffer_segment, dw 0
    36 00000144 0000                <1>  at SPECIFICATION_PACKET_STRUC.load_segment, dw 0
    37 00000146 0000                <1>  at SPECIFICATION_PACKET_STRUC.virtual_sectors, dw 0
    38 00000148 00                  <1>  at SPECIFICATION_PACKET_STRUC.cylinder_count, db 0
    39 00000149 00                  <1>  at SPECIFICATION_PACKET_STRUC.sector_count, db 0
    40 0000014A 00                  <1>  at SPECIFICATION_PACKET_STRUC.head_count, db 0
    41                              <1>  IEND
    42                              <1>  %define %1.packed_size %1+SPECIFICATION_PACKET_STRUC.packed_size
    43                              <1>  %define %1.boot_media_type %1+SPECIFICATION_PACKET_STRUC.boot_media_type
    44                              <1>  %define %1.drive_number %1+SPECIFICATION_PACKET_STRUC.drive_number
    45                              <1>  %define %1.controller_index %1+SPECIFICATION_PACKET_STRUC.controller_index
    46                              <1>  %define %1.logical_block_address %1+SPECIFICATION_PACKET_STRUC.logical_block_address
    47                              <1>  %define %1.device_specification %1+SPECIFICATION_PACKET_STRUC.device_specification
    48                              <1>  %define %1.buffer_segment %1+SPECIFICATION_PACKET_STRUC.buffer_segment
    49                              <1>  %define %1.load_segment %1+SPECIFICATION_PACKET_STRUC.load_segment
    50                              <1>  %define %1.virtual_sectors %1+SPECIFICATION_PACKET_STRUC.virtual_sectors
    51                              <1>  %define %1.cylinder_count %1+SPECIFICATION_PACKET_STRUC.cylinder_count
    52                              <1>  %define %1.sector_count %1+SPECIFICATION_PACKET_STRUC.sector_count
    53                              <1>  %define %1.head_count %1+SPECIFICATION_PACKET_STRUC.head_count
    22                                       DISK_ADDRESS_PACKET      diskAddressPacket,KERNELSTARTCS,KERNELSTARTIP
    67                              <1>  %1: ISTRUC DISK_ADDRESS_PACKET_STRUC
    68 0000014B 10                  <1>  at DISK_ADDRESS_PACKET_STRUC.size, db 16
    69 0000014C 00                  <1>  at DISK_ADDRESS_PACKET_STRUC.reserved, db 0
    70 0000014D 0100                <1>  at DISK_ADDRESS_PACKET_STRUC.sectors_to_read, dw 1
    71 0000014F 0000                <1>  at DISK_ADDRESS_PACKET_STRUC.offset, dw %3
    72 00000151 7000                <1>  at DISK_ADDRESS_PACKET_STRUC.segment, dw %2
    73 00000153 10000000            <1>  at DISK_ADDRESS_PACKET_STRUC.start_absolute_sector, dd 16
    74 00000157 00000000            <1>  at DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address, dd 0
    75                              <1>  IEND
    76                              <1>  %define %1.size %1+DISK_ADDRESS_PACKET_STRUC.size
    77                              <1>  %define %1.sectors_to_read %1+DISK_ADDRESS_PACKET_STRUC.sectors_to_read
    78                              <1>  %define %1.offset %1+DISK_ADDRESS_PACKET_STRUC.offset
    79                              <1>  %define %1.segment %1+DISK_ADDRESS_PACKET_STRUC.segment
    80                              <1>  %define %1.start_absolute_sector %1+DISK_ADDRESS_PACKET_STRUC.start_absolute_sector
    81                              <1>  %define %1.transfer_buffer_address %1+DISK_ADDRESS_PACKET_STRUC.transfer_buffer_address
    23                                               
    24                                  FlushCS:
    25                                       ; set segment registers same as codesegment
    26 0000015B FA                           cli                                                              ; Turn off intterrupts
    27 0000015C 8CC8                         mov       ax, cs                                                 ; boot Segment
    28 0000015E 8ED8                         mov       ds, ax
    29 00000160 8EC0                         mov       es, ax
    30 00000162 8ED0                         mov       ss, ax
    31 00000164 BCFFFF                       mov       sp, 0xFFFF                                             ; set stackpointer at end of current segment
    32 00000167 FB                           sti                                                              ; turn on interrupts
    33 00000168 8816[0500]                   mov       byte[bootdrive], dl                                    ; save boot drive
    34 0000016C 20D2                         and       dl, dl
    35 0000016E 744B                         jz        NonBootable                                            ; if result is zero then failure
    36                                  
    37                                       ; Call Check Extensions Present?
    38 00000170 8A16[0500]                   mov       dl, byte[bootdrive]                                    ; Prepare to read CD-ROM, load boot drive
    39 00000174 B441                         mov       ah, 0x41
    40 00000176 BBAA55                       mov       bx, 0x55AA                                             ; Signature?
    41 00000179 CD13                         int       0x13                                         
    42 0000017B 723E                         jc        NonBootable                                            ; disk is not bootable
    43                                  
    44                                       ; get status: 
    45 0000017D 8A16[0500]                   mov       dl, byte[bootdrive]                                    ; prepare to read CD-ROM, load boot drive
    46 00000181 B8014B                       mov       ax, 0x4B01
    47 00000184 BE[3801]                     mov       si, specificationPacket               
    48 00000187 CD13                         int       0x13
    49                                  
    50                                       ; DL still holds the bootdrive
    51 00000189 2216[3A01]                   and       dl, byte[specificationPacket.drive_number]             ; Load resultant drive information
    52 0000018D 742C                         jz        NonBootable                                            ; if result not zero then failure
    53                                  
    54 0000018F 8A16[0500]                   mov       dl, byte[bootdrive]                                    ; Set it up again
    55 00000193 B442                         mov       ah, 0x42                                               ; Read from drive function
    56 00000195 BE[4B01]                     mov       si, diskAddressPacket                                  ; Load SI with address of the Disk Address Packet
    57 00000198 CD13                         int       0x13                                                   ; Call read sector from drive
    58 0000019A 721F                         jc        NonBootable
    59                                  
    60 0000019C 8E06[5101]                   mov       es, word[diskAddressPacket.segment]
    61 000001A0 8B3E[4F01]                   mov       di, word[diskAddressPacket.offset]
    62 000001A4 26668B859E00                 mov       eax, dword[es:di+158]                                  ; LBA of root directory, where all things start.
    63 000001AA 66A3[5301]                   mov       dword[diskAddressPacket.start_absolute_sector], eax    ; Load packet with new address on CD of the root directory
    64 000001AE 8A16[0500]                   mov       dl, byte[bootdrive]                                    ; Set it up again
    65 000001B2 B442                         mov       ah, 0x42                                               ; Read from drive function
    66 000001B4 BE[4B01]                     mov       si, diskAddressPacket                                  ; Load SI with address of DAP
    67 000001B7 CD13                         int       0x13
    68 000001B9 7318                         jnc       SearchBootFile
    69                                  
    70                                  NonBootable:
    71 000001BB BE[0600]                     mov       si, pressAnyKey
    72                                       ; print message
    73 000001BE FC                           cld
    74                                  .nextbyte:
    75 000001BF AC                           lodsb                                                            ; Load SI into AL, increment SI one byte
    76 000001C0 20C0                         and       al, al
    77 000001C2 7506                         jnz       .printbyte
    78 000001C4 30E4                         xor       ah, ah
    79 000001C6 CD16                         int       0x16                                                   ; wait for key press
    80 000001C8 CD19                         int       0x19                                                   ; reboot system
    81                                  .printbyte:     
    82 000001CA B40E                         mov       ah, 0x0E
    83 000001CC BB0700                       mov       bx, 0x0007
    84 000001CF CD10                         int       0x10                                                   ; display character in AL
    85 000001D1 EBEC                         jmp       .nextbyte                                              ; repeat for next byte
    86                                  
    87                                  SearchBootFile:     
    88                                  .nextDirEntry:
    89                                      
    90 000001D3 268A05                       mov       al, byte[es:di]                                        ; Length of the current directory entry
    91 000001D6 A2[2E00]                     mov       byte[directoryEntrySize],al
    92 000001D9 26668B4502                   mov       eax, dword[es:di+2]                                    ; Starting sector of directory entry
    93 000001DE 66A3[2F00]                   mov       dword[fileSector], eax
    94 000001E2 26668B450A                   mov       eax, dword[es:di+10]                                   ; Size of file on CD/DVD/BD
    95 000001E7 66A3[3300]                   mov       dword[fileSize], eax
    96                                  
    97 000001EB 268A4520                     mov       al, byte[es:di+32]                                     ; File's name length (see El Torito of ISO:9660 or CDROM.ASM)
    98 000001EF FEC8                         dec       al                                                     ; for trailing ;
    99 000001F1 FEC8                         dec       al                                                     ; for trailing 1
   100 000001F3 A2[3700]                     mov       byte[fileNameLength], al
   101                                  
   102 000001F6 31DB                         xor       bx, bx
   103 000001F8 31C9                         xor       cx, cx
   104 000001FA 89FE                         mov       si, di
   105 000001FC 83C621                       add       si, 33
   106 000001FF BB[3800]                     mov       bx, fileNameEntry
   107 00000202 A0[3700]                     mov       al, byte[fileNameLength]
   108                                  
   109                                  .LoopFileNameEntry:
   110                                  
   111 00000205 268A04                       mov       al, byte[es:si]
   112 00000208 3E8807                       mov       byte[ds:bx], al
   113 0000020B 43                           inc       bx
   114 0000020C 41                           inc       cx
   115 0000020D 46                           inc       si
   116 0000020E 31C0                         xor       ax, ax
   117 00000210 A0[3700]                     mov       al, byte[fileNameLength]
   118 00000213 39C1                         cmp       cx, ax
   119 00000215 75EE                         jne        .LoopFileNameEntry
   120                                  
   121 00000217 3EC60700                     mov       byte[ds:bx],0
   122                                  
   123 0000021B BE[3800]                     mov       si, fileNameEntry
   124 0000021E 57                           push      di
   125 0000021F BF[2300]                     mov       di, fileName
   126                                      
   127                                  .CompareLoop:
   128                                  
   129 00000222 8A04                         mov       al, byte[si]        ; Grab byte from ESI
   130 00000224 8A1D                         mov       bl, byte[di]        ; Grab byte from EDI
   131 00000226 38D8                         cmp       al, bl              ; Compare if they are equal
   132 00000228 7508                         jne       .NotEqual           ; They aren't equal
   133                                  
   134 0000022A 20C0                         and       al, al              ; Both bytes are null
   135 0000022C 7407                         jz        .compareDone
   136                                  
   137 0000022E 47                           inc       di             ; Increment EDI
   138 0000022F 46                           inc       si             ; Increment ESI
   139 00000230 EBF0                         jmp       .CompareLoop           ; Start looping
   140                                  
   141                                  .NotEqual:
   142 00000232 F9                           stc                        ; Set the carry flag to indicate failure
   143 00000233 EB01                         jmp       .compareEnd
   144                                  
   145                                  .compareDone:
   146                                  
   147 00000235 F8                           clc                 ; Clear the carry flag to indicate success
   148                                  
   149                                  .compareEnd:
   150                                      
   151 00000236 5F                           pop       di
   152 00000237 7328                         jnc       .nextsector
   153                                  
   154 00000239 31C9                         xor       cx, cx                                   ; Prepare CX to do math for DI
   155 0000023B 8A0E[2E00]                   mov       cl, byte[directoryEntrySize]                 ; Get the size of the directory entry
   156 0000023F 01CF                         add       di, cx                                   ; Add that size to the DI to get to the next record
   157 00000241 26803D00                     cmp       byte[es:di],0                          ; Is the next entry = 0?
   158 00000245 0F8472FF                     je        NonBootable                                     ; If so, we're at the end of the directory, move on
   159                                  
   160 00000249 31C9                         xor       cx, cx
   161 0000024B BB[3800]                     mov       bx, fileNameEntry
   162                                  
   163                                  .ClearFileNameEntry:
   164                                  
   165 0000024E 3EC60700                     mov       byte[ds:bx],0                           ; Erase the begining of the
   166 00000252 43                           inc       bx
   167 00000253 41                           inc       cx
   168 00000254 81F9FE00                     cmp       cx, 254
   169 00000258 72F4                         jb        .ClearFileNameEntry
   170 0000025A 3EC60700                     mov       byte[ds:bx],0
   171                                       ;inc       byte[fileEntryNumber]
   172 0000025E E972FF                       jmp       SearchBootFile.nextDirEntry
   173                                  
   174                                       
   175                                  .nextsector:     
   176 00000261 66A1[2F00]                   mov       eax, dword[fileSector]
   177 00000265 66A3[5301]                   mov       dword[diskAddressPacket.start_absolute_sector], eax             ; Save the starting sector into DAP
   178 00000269 66A1[3300]                   mov       eax, dword[fileSize]
   179 0000026D 6631D2                       xor       edx, edx
   180 00000270 66BB00080000                 mov       ebx, 2048
   181 00000276 66F7F3                       div       ebx
   182 00000279 6640                         inc       eax
   183 0000027B A3[4D01]                     mov       [diskAddressPacket.sectors_to_read],AX    ; Save number of sectors to read
   184                                  
   185 0000027E 8A16[0500]                   mov       dl, byte[bootdrive]                      ; Set it up again
   186 00000282 B442                         mov       ah,0x42                                  ; Read from drive function
   187 00000284 BE[4B01]                     mov       si,diskAddressPacket                    ; Load SI with address of the Disk Address Packet
   188 00000287 CD13                         int       0x13                                     ; Call read sector from drive
   189 00000289 0F822EFF                     jc        NonBootable                                  ; Nope, hosed, get out
   190                                  
   191 0000028D 8A16[0500]                   mov       dl,byte[bootdrive]                      ; Drive into DL for booting
   192                                       
   193                                       
   194 00000291 EA00007000                   jmp       KERNELSTARTCS:KERNELSTARTIP
