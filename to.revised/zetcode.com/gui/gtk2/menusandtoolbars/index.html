<!DOCTYPE html> 
<html lang="en">
<head>
<title>Menus and toolbars in GTK+</title>
<link rel="stylesheet" href="/cfg/style.css" type="text/css">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="keywords" content="GUI, menus, toolbars, GTK+ library, C, Linux">
<meta name="description" content="In this part of the GTK+ tutorial, we cover menus 
and toolbars. We demonstrate how to create a classic menubar with menus and menu items, 
a popup menu, and a toolbar.">
<meta name="author" content="Jan Bodnar">

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-5536206-1', 'auto');
  ga('send', 'pageview');

</script>

</head>

<body>

<header>

<div>
<a href="/" title="Home">ZetCode</a>
</div>

<nav>
    <a title="All tutorials" href="/all/">All</a>
    <a title="Spring Boot tutorials" href="/all/#springboot">Spring Boot</a>
    <a title="Python tutorials" href="/all/#python">Python</a>
    <a title="C# tutorials" href="/all/#csharp">C#</a>
    <a title="Java tutorials" href="/all/#java">Java</a>
    <a title="JavaScript tutorials" href="/all/#js">JavaScript</a>
    <a title="Subscribe to ZetCode news" href="http://zetcode.us13.list-manage.com/subscribe?u=9def9ccd4c70dbbaf691f90fc&id=6556210f80">Subscribe</a>
</nav>

</header>

<div class="container">

<div class="ltow">
    
<div id="ebooks">

<h2 class="blu">Ebooks</h2>

<ul>
<li><a href="/ebooks/advancedpyqt5/">PyQt5 ebook</a></li>
<li><a href="/ebooks/tkinter/">Tkinter ebook</a></li>
<li><a href="/ebooks/sqlitepython/">SQLite Python</a></li>
<li><a href="/ebooks/advancedwxpython/">wxPython ebook</a></li>
<li><a href="/ebooks/windowsapi/">Windows API ebook</a></li>
<li><a href="/ebooks/advancedjavaswing/">Java Swing ebook</a></li>
<li><a href="/ebooks/javagames/">Java games ebook</a></li>
<li><a href="/ebooks/mysqljava/">MySQL Java ebook</a></li>
</ul>

</div>

</div>


<div class="content">


<nav>
<a href="..">Contents</a>
<a href="../firstprograms/">Previous</a>
<a href="../gtklayoutmanagement/">Next</a>
</nav>


<h1>Menus and toolbars in GTK+</h1>

<p class="last_mod">
last modified July 16, 2020 
</p>


<p>
In this part of the GTK+ programming tutorial, we work with menus and 
toolbars. A <em>menubar</em> is a common part of a GUI application. It is 
a group of commands located in various menus.
</p>

<div class="ad-top square-fix-ad">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- square-fixed-2020 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:250px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="6775384732"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<p>
<code>GtkMenuBar</code> is a widget that creates a menubar. It contains one to 
many <code>GtkMenuItems</code>. A menu item is an object which a user can select.
<code>GtkMenu</code> implements a drop down menu consisting of a list of 
<code>GtkMenuItem</code> objects, which can be navigated and activated by the user to 
perform application functions. A <code>GtkMenu</code> is attached to the menu items
of the menubar or menu items of another menu.
</p>

<figure>
<img src="/img/gui/cgtk/menus.png" alt="Menus">
<figcaption>Figure: Menus</figcaption>
</figure>

<p>
The image shows the structure of a menubar and its menus.
</p>




<h2>Simple menu example</h2>

<p>
In our first example, we create a menubar with one File menu. 
</p>

<div class="codehead">simplemenu.c</div>
<pre class="code">
#include &lt;gtk/gtk.h&gt;

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *vbox;

  GtkWidget *menubar;
  GtkWidget *fileMenu;
  GtkWidget *fileMi;
  GtkWidget *quitMi;

  gtk_init(&amp;argc, &amp;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_window_set_title(GTK_WINDOW(window), "Simple menu");

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);

  menubar = gtk_menu_bar_new();
  fileMenu = gtk_menu_new();

  fileMi = gtk_menu_item_new_with_label("File");
  quitMi = gtk_menu_item_new_with_label("Quit");

  gtk_menu_item_set_submenu(GTK_MENU_ITEM(fileMi), fileMenu);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), quitMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(menubar), fileMi);
  gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 0);

  g_signal_connect(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), NULL);

  g_signal_connect(G_OBJECT(quitMi), "activate",
        G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>
The menu in the examle has one menu item. By selecting the item, the application quits. 
</p>

<pre class="explanation">
menubar = gtk_menu_bar_new();
</pre>

<p>
The <code>gtk_menu_bar_new()</code> creates a new <code>GtkMenuBar</code>. 
</p>

<pre class="explanation">
filemenu = gtk_menu_new();
</pre>

<p>
The <code>gtk_menu_new()</code> function creates a new <code>GtkMenu</code>. 
</p>

<pre class="explanation">
gtk_menu_item_set_submenu(GTK_MENU_ITEM(fileMi), fileMenu);
</pre>

<p>
The <code>fileMenu</code> is set to the File menu item with the 
<code>gtk_menu_item_set_submenu()</code> function. Menus are containers
which hold menu items. They are themselves plugged to a particular menu item.
</p>

<pre class="explanation">
gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), quitMi);
</pre>

<p>
The <code>quitMi</code> is added to the File menu with the <code>gtk_menu_shell_append()</code> 
function. 
</p>

<pre class="explanation">
gtk_menu_shell_append(GTK_MENU_SHELL(menubar), fileMi);
</pre>

<p>
The File menu item is added to the menubar with the <code>gtk_menu_shell_append()</code> 
function. Both <code>GtkMenu</code> and <code>GtkMenuBar</code> are derived from 
the <code>GtkMenuShell</code>.
</p>

<pre class="explanation">
g_signal_connect(G_OBJECT(quitMi), "activate",
    G_CALLBACK(gtk_main_quit), NULL);
</pre>

<p>
By selecting the quit menu item, we terminate the application.
</p>

<figure>
<img src="/img/gui/cgtk/simplemenu.png" alt="Simple menu">
<figcaption>Figure: Simple menu</figcaption>
</figure>


<h2>Submenu</h2>

<p>
The next example demonstrates how to create a submenu. A submenu
is a menu inside another menu.
</p>

<div class="codehead">submenu.c</div>
<pre class="code">
#include &lt;gtk/gtk.h&gt;

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *vbox;

  GtkWidget *menubar;
  GtkWidget *fileMenu;
  GtkWidget *imprMenu;
  GtkWidget *sep;
  GtkWidget *fileMi;
  GtkWidget *imprMi;
  GtkWidget *feedMi;
  GtkWidget *bookMi;
  GtkWidget *mailMi;
  GtkWidget *quitMi;

  gtk_init(&amp;argc, &amp;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_window_set_title(GTK_WINDOW(window), "Submenu");

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);

  menubar = gtk_menu_bar_new();
  
  fileMenu = gtk_menu_new();
  fileMi = gtk_menu_item_new_with_label("File");
  
  imprMenu = gtk_menu_new();
  imprMi = gtk_menu_item_new_with_label("Import");
  feedMi = gtk_menu_item_new_with_label("Import news feed...");
  bookMi = gtk_menu_item_new_with_label("Import bookmarks...");
  mailMi = gtk_menu_item_new_with_label("Import mail...");
  
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(imprMi), imprMenu);
  gtk_menu_shell_append(GTK_MENU_SHELL(imprMenu), feedMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(imprMenu), bookMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(imprMenu), mailMi);
  sep = gtk_separator_menu_item_new();  
  quitMi = gtk_menu_item_new_with_label("Quit");

  gtk_menu_item_set_submenu(GTK_MENU_ITEM(fileMi), fileMenu);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), imprMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), sep);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), quitMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(menubar), fileMi);
  gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 0);

  g_signal_connect(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), NULL);

  g_signal_connect(G_OBJECT(quitMi), "activate",
        G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>
The example creates a menu inside another menu. The submenu has
three menu items. We also add a horizontal separator.
</p>

<pre class="explanation">
imprMenu = gtk_menu_new();
imprMi = gtk_menu_item_new_with_label("Import");
feedMi = gtk_menu_item_new_with_label("Import news feed...");
bookMi = gtk_menu_item_new_with_label("Import bookmarks...");
mailMi = gtk_menu_item_new_with_label("Import mail...");
</pre>

<p>
This is a submenu with its menu items.
</p>

<pre class="explanation">
gtk_menu_item_set_submenu(GTK_MENU_ITEM(imprMi), imprMenu);
</pre>

<p>
The <code>imprMenu</code> submenu is added to its own menu item.
</p>

<pre class="explanation">
gtk_menu_shell_append(GTK_MENU_SHELL(imprMenu), feedMi);
gtk_menu_shell_append(GTK_MENU_SHELL(imprMenu), bookMi);
gtk_menu_shell_append(GTK_MENU_SHELL(imprMenu), mailMi);
</pre>

<p>
The three menu items are added to the submenu with the
<code>gtk_menu_shell_append()</code> function.
</p>

<pre class="explanation">
sep = gtk_separator_menu_item_new();
</pre>

<p>
A horizontal menu separator is created with the <code>gtk_separator_menu_item_new()</code>
function.
</p>

<pre class="explanation">
gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), imprMi);
gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), sep);
</pre>

<p>
The <code>imprMi</code> and the separator are added to the File menu
with the <code>gtk_menu_shell_append()</code> function.
</p>

<figure>
<img src="/img/gui/cgtk/submenu.png" alt="Submenu">
<figcaption>Figure: Submenu</figcaption>
</figure>



<h2>Image menus, mnemonics &amp; accelerators</h2>

<p>
<code>GtkImageMenuItem</code> is a menu item which has an icon next to 
the text label. Since the user can disable displaying of menu icons, we still 
need to fill in the text label. <em>Accelerators</em> are keyboard shortcuts for activating 
a menu item. <em>Mnemonics</em> are keyboard shortcuts for
GUI elements. They are represented as underlined characters. Note 
that in some environments, we first need to press the mouseless 
modifier (usually <code>Alt</code>) to show the underlined characters.
</p>

<p>
We might also have our environment configured not to show menu images. 
To turn the menu images on, we launch the <code>gconf-editor</code> and
go to <code>/desktop/gnome/interface/menus_have_icons</code> and check the
option.
</p>

<div class="codehead">imagemenu.c</div>
<pre class="code">
#include &lt;gtk/gtk.h&gt;
#include &lt;gdk/gdkkeysyms.h&gt;

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *vbox;

  GtkWidget *menubar;
  GtkWidget *fileMenu;
  GtkWidget *fileMi;
  GtkWidget *newMi;
  GtkWidget *openMi;
  GtkWidget *quitMi;

  GtkWidget *sep;

  GtkAccelGroup *accel_group = NULL;

  gtk_init(&amp;argc, &amp;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_window_set_title(GTK_WINDOW(window), "Images");

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);

  menubar = gtk_menu_bar_new();
  fileMenu = gtk_menu_new();

  accel_group = gtk_accel_group_new();
  gtk_window_add_accel_group(GTK_WINDOW(window), accel_group);

  fileMi = gtk_menu_item_new_with_mnemonic("_File");
  newMi = gtk_image_menu_item_new_from_stock(GTK_STOCK_NEW, NULL);
  openMi = gtk_image_menu_item_new_from_stock(GTK_STOCK_OPEN, NULL);
  sep = gtk_separator_menu_item_new();
  quitMi = gtk_image_menu_item_new_from_stock(GTK_STOCK_QUIT, accel_group);

  gtk_widget_add_accelerator(quitMi, "activate", accel_group, 
      GDK_q, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE); 

  gtk_menu_item_set_submenu(GTK_MENU_ITEM(fileMi), fileMenu);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), newMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), openMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), sep);
  gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu), quitMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(menubar), fileMi);
  gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 0);

  g_signal_connect(G_OBJECT(window), "destroy",
      G_CALLBACK(gtk_main_quit), NULL);

  g_signal_connect(G_OBJECT(quitMi), "activate",
      G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>
The example has three menu items with icons. The menu items can be selected
with mnemonics. The Quit menu item has a keyboard accelerator.
</p>

<pre class="explanation">
accel_group = gtk_accel_group_new();
gtk_window_add_accel_group(GTK_WINDOW(window), accel_group);
...
quitMi = gtk_image_menu_item_new_from_stock(GTK_STOCK_QUIT, accel_group);

gtk_widget_add_accelerator(quitMi, "activate", accel_group, 
    GDK_q, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE); 
</pre>

<p>
An accelerator group is a  group of keyboard accelerators, typically attached 
to a toplevel window. Here we create the <kbd>Ctrl</kbd>+<kbd>Q</kbd> keyboard accelerator.
</p>

<pre class="explanation">
fileMi = gtk_menu_item_new_with_mnemonic("_File");
</pre>

<p>
The <code>gtk_menu_item_new_with_mnemonic()</code> creates a menu item which can
have a mnemonic. Underscores in label indicate the mnemonic for the menu item.
The character is combined with the mouseless modifier, usually <code>Alt</code>.
In our case, we have created the <kbd>Alt</kbd>+<kbd>F</kbd> mnemonic.
</p>

<pre class="explanation">
newMi = gtk_image_menu_item_new_from_stock(GTK_STOCK_NEW, NULL);
openMi = gtk_image_menu_item_new_from_stock(GTK_STOCK_OPEN, NULL);
</pre>

<p>
The <code>gtk_image_menu_item_new_from_stock()</code> creates a 
<code>GtkImageMenuItem</code> containing the image and text from a stock item. 
</p>

<figure>
<img src="/img/gui/cgtk/imagemenu.png" alt="Menu items with icons">
<figcaption>Figure: Menu items with icons</figcaption>
</figure>


<div class="ad-mid square-fix-ad">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- square-fixed-2020 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:250px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="6775384732"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<h2>CheckMenuItem</h2>

<p>
A <code>GtkCheckMenuItem</code> is a menu item with a check box.
</p>

<div class="codehead">checkmenuitem.c</div>
<pre class="code">
#include &lt;gtk/gtk.h&gt;

void toggle_statusbar(GtkWidget *widget, gpointer statusbar) {
    
  if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(widget))) {
      
    gtk_widget_show(statusbar);
  } else {
      
    gtk_widget_hide(statusbar);
  }
}

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *vbox;

  GtkWidget *menubar;
  GtkWidget *viewmenu;
  GtkWidget *view;
  GtkWidget *tog_stat;
  GtkWidget *statusbar;

  gtk_init(&amp;argc, &amp;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_window_set_title(GTK_WINDOW(window), "GtkCheckMenuItem");

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);

  menubar = gtk_menu_bar_new();
  viewmenu = gtk_menu_new();

  view = gtk_menu_item_new_with_label("View");
  tog_stat = gtk_check_menu_item_new_with_label("View statusbar");
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(tog_stat), TRUE);

  gtk_menu_item_set_submenu(GTK_MENU_ITEM(view), viewmenu);
  gtk_menu_shell_append(GTK_MENU_SHELL(viewmenu), tog_stat);
  gtk_menu_shell_append(GTK_MENU_SHELL(menubar), view);
  gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 0);

  statusbar = gtk_statusbar_new();
  gtk_box_pack_end(GTK_BOX(vbox), statusbar, FALSE, TRUE, 0);

  g_signal_connect(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), NULL);

  g_signal_connect(G_OBJECT(tog_stat), "activate", 
        G_CALLBACK(toggle_statusbar), statusbar);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>
The example contains a <code>GtkCheckMenuItem</code> in a View menu. 
If the check box is activated, the statusbar widget is shown. 
</p>

<pre class="explanation">
tog_stat = gtk_check_menu_item_new_with_label("View statusbar");
</pre>

<p>
The <code>gtk_check_menu_item_new_with_label()</code> function 
creates a new <code>CheckMenuItem</code>.
</p>

<pre class="explanation">
statusbar = gtk_statusbar_new();
</pre>

<p>
The <code>gtk_statusbar_new()</code> function creates a new <code>GtkStatusbar</code> widget.
It is used to report messages of minor importance to the user.
</p>

<pre class="explanation">
if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(widget))) {
    
  gtk_widget_show(statusbar);
} else {
    
  gtk_widget_hide(statusbar);
}
</pre>

<p>
If the check box in the menu item is activated, we show the statusbar widget; 
otherwise the statusbar is hidden. 
</p>

<figure>
<img src="/img/gui/cgtk/checkmenuitem.png" alt="GtkCheckMenuItem">
<figcaption>Figure: GtkCheckMenuItem</figcaption>
</figure>


<h2>Popup menu</h2>

<p>
In the next example, we create a popup menu. A popup menu is also called a context menu. 
This type of menu is usually shown when we right click on a GUI object.
</p>

<div class="codehead">popupmenu.c</div>
<pre class="code">
#include &lt;gtk/gtk.h&gt;

int show_popup(GtkWidget *widget, GdkEvent *event) {
  
  const gint RIGHT_CLICK = 3;
    
  if (event->type == GDK_BUTTON_PRESS) {
      
      GdkEventButton *bevent = (GdkEventButton *) event;
      
      if (bevent->button == RIGHT_CLICK) {      
          
          gtk_menu_popup(GTK_MENU(widget), NULL, NULL, NULL, NULL,
              bevent->button, bevent->time);
          }
          
      return TRUE;
  }

  return FALSE;
}

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *ebox;
  GtkWidget *pmenu;
  GtkWidget *hideMi;
  GtkWidget *quitMi;

  gtk_init(&amp;argc, &amp;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_window_set_title(GTK_WINDOW(window), "Popup menu");

  ebox = gtk_event_box_new();
  gtk_container_add(GTK_CONTAINER(window), ebox);
  
  pmenu = gtk_menu_new();
  
  hideMi = gtk_menu_item_new_with_label("Minimize");
  gtk_widget_show(hideMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(pmenu), hideMi);
  
  quitMi = gtk_menu_item_new_with_label("Quit");
  gtk_widget_show(quitMi);
  gtk_menu_shell_append(GTK_MENU_SHELL(pmenu), quitMi);
  
  g_signal_connect_swapped(G_OBJECT(hideMi), "activate", 
      G_CALLBACK(gtk_window_iconify), GTK_WINDOW(window));    
  
  g_signal_connect(G_OBJECT(quitMi), "activate", 
      G_CALLBACK(gtk_main_quit), NULL);  

  g_signal_connect(G_OBJECT(window), "destroy",
      G_CALLBACK(gtk_main_quit), NULL);
        
  g_signal_connect_swapped(G_OBJECT(ebox), "button-press-event", 
      G_CALLBACK(show_popup), pmenu);  

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>
In the code example, we create a popup menu with two menu items. The first minimizes 
the window, and the second terminates the application.
</p>

<pre class="explanation">
ebox = gtk_event_box_new();
gtk_container_add(GTK_CONTAINER(window), ebox);
</pre>

<p>
In order to process button press events, we create a <code>GtkEventBox</code>.
</p>

<pre class="explanation">
pmenu = gtk_menu_new();
</pre>

<p>
A popup menu is a <code>GtkMenu</code>.
</p>

<pre class="explanation">
hideMi = gtk_menu_item_new_with_label("Minimize");
gtk_widget_show(hideMi);
gtk_menu_shell_append(GTK_MENU_SHELL(pmenu), hideMi);
</pre>

<p>
The first menu item is added to the popup menu.
</p>

<pre class="explanation">
g_signal_connect_swapped(G_OBJECT(hideMi), "activate", 
    G_CALLBACK(gtk_window_iconify), GTK_WINDOW(window)); 
</pre>

<p>
Selecting the first menu item minimizes the window. We connect the <code>activate</code>
signal of the Hide menu item to the <code>gtk_window_iconify()</code> function. 
The term iconify is a synonym for minimize.
</p>

<pre class="explanation">
g_signal_connect_swapped(G_OBJECT(ebox), "button_press_event", 
    G_CALLBACK(show_popup), pmenu);   
</pre>

<p>
When a mouse button is pressed, a <code>button-press-event</code> signal is emitted.
We connect the signal to the <code>show_popup()</code> function and pass it the 
popup menu.
</p>

<pre class="explanation">
if (event->type == GDK_BUTTON_PRESS) {
</pre>

<p>
Inside the event handler, we check for the button press event type.
</p>

<pre class="explanation">
if (bevent->button == RIGHT_CLICK) {      
    
    gtk_menu_popup(GTK_MENU(widget), NULL, NULL, NULL, NULL,
        bevent->button, bevent->time);
}
</pre>

<p>
When the button triggering the signal is a right mouse button, we show 
the popup menu with the <code>gtk_menu_popup()</code> function.
</p>

<figure>
<img src="/img/gui/cgtk/popupmenu.png" alt="Popup menu">
<figcaption>Figure: Popup menu</figcaption>
</figure>


<h2>A toolbar</h2>

<p>
Menus group commands that we can use in application. Toolbars provide a 
quick access to the most frequently used commands. <code>GtkToolbar</code>
is a toolbar widget in GTK+. A toolbar can contain instances of a subclass of a
<code>GtkToolItem</code>, e.g. a <code>GtkToolButton</code> or a <code>GtkSeparatorToolItem</code>.
</p>

<div class="codehead">toolbar.c</div>
<pre class="code">
#include &lt;gtk/gtk.h&gt;

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *vbox;
  
  GtkWidget *toolbar;
  GtkToolItem *newTb;
  GtkToolItem *openTb;
  GtkToolItem *saveTb;
  GtkToolItem *sep;
  GtkToolItem *exitTb;

  gtk_init(&amp;argc, &amp;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_window_set_title(GTK_WINDOW(window), "toolbar");

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);

  toolbar = gtk_toolbar_new();
  gtk_toolbar_set_style(GTK_TOOLBAR(toolbar), GTK_TOOLBAR_ICONS);

  newTb = gtk_tool_button_new_from_stock(GTK_STOCK_NEW);
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), newTb, -1);

  openTb = gtk_tool_button_new_from_stock(GTK_STOCK_OPEN);
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), openTb, -1);

  saveTb = gtk_tool_button_new_from_stock(GTK_STOCK_SAVE);
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), saveTb, -1);

  sep = gtk_separator_tool_item_new();
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), sep, -1); 

  exitTb = gtk_tool_button_new_from_stock(GTK_STOCK_QUIT);
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), exitTb, -1);

  gtk_box_pack_start(GTK_BOX(vbox), toolbar, FALSE, FALSE, 5);

  g_signal_connect(G_OBJECT(exitTb), "clicked", 
        G_CALLBACK(gtk_main_quit), NULL);

  g_signal_connect(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>
The code example creates simple toolbar example. 
</p>

<pre class="explanation">
toolbar = gtk_toolbar_new();
</pre>

<p>
The <code>gtk_toolbar_new()</code> function creates a new <code>GtkToolBar</code> widget.
</p>

<pre class="explanation">
gtk_toolbar_set_style(GTK_TOOLBAR(toolbar), GTK_TOOLBAR_ICONS)
</pre>

<p>
The <code>gtk_toolbar_set_style()</code> function alters the view of toolbar to display 
either icons only, text only, or both. Passing the <code>GTK_TOOLBAR_ICONS</code> constant
makes the toolbar show only icons.
</p>

<pre class="explanation">
newTb = gtk_tool_button_new_from_stock(GTK_STOCK_NEW);
</pre>

<p>
The <code>gtk_tool_button_new_from_stock()</code> function creates a new <code>GtkToolButton</code> 
containing the image and text from a stock item.
</p>

<pre class="explanation">
gtk_toolbar_insert(GTK_TOOLBAR(toolbar), new, -1);
</pre>

<p>
The <code>gtk_toolbar_insert()</code> function inserts a <code>GtkToolItem</code> into the 
toolbar at the specified position. If the position is negative, the item is appended to the 
end of the toolbar.
</p>

<pre class="explanation">
sep = gtk_separator_tool_item_new();
gtk_toolbar_insert(GTK_TOOLBAR(toolbar), sep, -1); 
</pre>

<p>
The <code>gtk_separator_tool_item_new()</code> function creates a new <code>GtkSeparatorToolItem</code>.
It is inserted into the toolbar with the <code>gtk_toolbar_insert()</code> function.
</p>

<figure>
<img src="/img/gui/cgtk/toolbar.png" alt="Toolbar">
<figcaption>Figure: Toolbar</figcaption>
</figure>


<h2>Undo redo</h2>

<p>
The following example demonstrates how to inactivate toolbar buttons 
on the toolbar. It is a common practice in GUI programming. For example the Save button; 
if we save all changes of our document to the disk, the Save button is inactivated
in most text editors. This way the application indicates to the user that all changes 
are already saved.
</p>

<div class="codehead">undoredo.c</div>
<pre class="code">
#include &lt;gtk/gtk.h&gt;

void undo_redo(GtkWidget *widget,  gpointer item) {
    
  static gint count = 2;
  const gchar *name = gtk_widget_get_name(widget);
  
  if (g_strcmp0(name, "undo") ) {
    count++;
  } else {
    count--;
  }
  
  if (count &lt; 0) {
     gtk_widget_set_sensitive(widget, FALSE);
     gtk_widget_set_sensitive(item, TRUE);
  } 

  if (count > 5) {
     gtk_widget_set_sensitive(widget, FALSE);
     gtk_widget_set_sensitive(item, TRUE);
  }
}

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *vbox;

  GtkWidget *toolbar;
  GtkToolItem *undo;
  GtkToolItem *redo;
  GtkToolItem *sep;
  GtkToolItem *exit;

  gtk_init(&amp;argc, &amp;argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_window_set_title(GTK_WINDOW(window), "Undo redo");

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);


  toolbar = gtk_toolbar_new();
  gtk_toolbar_set_style(GTK_TOOLBAR(toolbar), GTK_TOOLBAR_ICONS);

  gtk_container_set_border_width(GTK_CONTAINER(toolbar), 2);

  undo = gtk_tool_button_new_from_stock(GTK_STOCK_UNDO);
  gtk_widget_set_name(GTK_WIDGET(undo), "undo");
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), undo, -1);

  redo = gtk_tool_button_new_from_stock(GTK_STOCK_REDO);
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), redo, -1);

  sep = gtk_separator_tool_item_new();
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), sep, -1); 

  exit = gtk_tool_button_new_from_stock(GTK_STOCK_QUIT);
  gtk_toolbar_insert(GTK_TOOLBAR(toolbar), exit, -1);

  gtk_box_pack_start(GTK_BOX(vbox), toolbar, FALSE, FALSE, 0);

  g_signal_connect(G_OBJECT(undo), "clicked", 
        G_CALLBACK(undo_redo), redo);

  g_signal_connect(G_OBJECT(redo), "clicked", 
        G_CALLBACK(undo_redo), undo);

  g_signal_connect(G_OBJECT(exit), "clicked", 
        G_CALLBACK(gtk_main_quit), NULL);

  g_signal_connect(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>
Our example creates Undo and Redo buttons from the GTK+ stock resources. 
After several clicks each of the buttons is inactivated. The buttons are grayed out.
</p>

<pre class="explanation">
if (count &lt; 0) {
   gtk_widget_set_sensitive(widget, FALSE);
   gtk_widget_set_sensitive(item, TRUE);
} 

if (count > 5) {
   gtk_widget_set_sensitive(widget, FALSE);
   gtk_widget_set_sensitive(item, TRUE);
}
</pre>

<p>
The <code>gtk_widget_set_sensitive()</code> function is used 
to activate or inactivate the toolbar buttons.
</p>


<figure>
<img src="/img/gui/cgtk/undoredo.png" alt="Undo redo">
<figcaption>Figure: Undo redo</figcaption>
</figure>

<p>
In this chapter we have covered about menus and toolbars in GTK+.
</p>


<div class="ad-bot square-fix-ad">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- square-fixed-2020 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:250px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="6775384732"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<nav>
<a href="..">Contents</a> 
<a href="../firstprograms/">Previous</a>
<a href="../gtklayoutmanagement/">Next</a>
</nav>



</div> <!-- content  -->

</div> <!-- container  -->

</body>
</html>



