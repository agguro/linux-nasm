<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>NASM - The Netwide Assembler</title>
<link href="nasmdoc.css" rel="stylesheet" type="text/css" />
<link href="local.css" rel="stylesheet" type="text/css" />
</head>
<body>
<ul class="navbar">
<li class="first"><a class="prev" href="nasmdoc9.html">Chapter 9</a></li>
<li><a class="next" href="nasmdo11.html">Chapter 11</a></li>
<li><a class="toc" href="nasmdoc0.html">Contents</a></li>
<li class="last"><a class="index" href="nasmdoci.html">Index</a></li>
</ul>
<div class="title">
<h1>NASM - The Netwide Assembler</h1>
<span class="subtitle">version 2.15.05</span>
</div>
<div class="contents"
>
<h2 id="chapter-10">Chapter 10: Writing 32-bit Code (Unix, Win32, DJGPP)</h2>
<p>This chapter attempts to cover some of the common issues involved when
writing 32-bit code, to run under Win32 or Unix, or to be linked with C
code generated by a Unix-style C compiler such as DJGPP. It covers how to
write assembly code to interface with 32-bit C routines, and how to write
position-independent code for shared libraries.</p>
<p>Almost all 32-bit code, and in particular all code running under
<code>Win32</code>, <code>DJGPP</code> or any of the PC Unix variants, runs
in <em>flat</em> memory model. This means that the segment registers and
paging have already been set up to give you the same 32-bit 4Gb address
space no matter what segment you work relative to, and that you should
ignore all segment registers completely. When writing flat-model
application code, you never need to use a segment override or modify any
segment register, and the code-section addresses you pass to
<code>CALL</code> and <code>JMP</code> live in the same address space as
the data-section addresses you access your variables by and the
stack-section addresses you access local variables and procedure parameters
by. Every address is 32 bits long and contains only an offset part.</p>
<h3 id="section-10.1">10.1 Interfacing to 32-bit C Programs</h3>
<p>A lot of the discussion in <a href="nasmdoc9.html#section-9.4">section
9.4</a>, about interfacing to 16-bit C programs, still applies when working
in 32 bits. The absence of memory models or segmentation worries simplifies
things a lot.</p>
<h4 id="section-10.1.1">10.1.1 External Symbol Names</h4>
<p>Most 32-bit C compilers share the convention used by 16-bit compilers,
that the names of all global symbols (functions or data) they define are
formed by prefixing an underscore to the name as it appears in the C
program. However, not all of them do: the <code>ELF</code> specification
states that C symbols do <em>not</em> have a leading underscore on their
assembly-language names.</p>
<p>The older Linux <code>a.out</code> C compiler, all <code>Win32</code>
compilers, <code>DJGPP</code>, and <code>NetBSD</code> and
<code>FreeBSD</code>, all use the leading underscore; for these compilers,
the macros <code>cextern</code> and <code>cglobal</code>, as given in
<a href="nasmdoc9.html#section-9.4.1">section 9.4.1</a>, will still work.
For <code>ELF</code>, though, the leading underscore should not be used.</p>
<p>See also <a href="nasmdoc2.html#section-2.1.28">section 2.1.28</a>.</p>
<h4 id="section-10.1.2">10.1.2 Function Definitions and Function Calls</h4>
<p>The C calling convention in 32-bit programs is as follows. In the
following description, the words <em>caller</em> and <em>callee</em> are
used to denote the function doing the calling and the function which gets
called.</p>
<ul>
<li>
<p>The caller pushes the function's parameters on the stack, one after
another, in reverse order (right to left, so that the first argument
specified to the function is pushed last).</p>
</li>
<li>
<p>The caller then executes a near <code>CALL</code> instruction to pass
control to the callee.</p>
</li>
<li>
<p>The callee receives control, and typically (although this is not
actually necessary, in functions which do not need to access their
parameters) starts by saving the value of <code>ESP</code> in
<code>EBP</code> so as to be able to use <code>EBP</code> as a base pointer
to find its parameters on the stack. However, the caller was probably doing
this too, so part of the calling convention states that <code>EBP</code>
must be preserved by any C function. Hence the callee, if it is going to
set up <code>EBP</code> as a frame pointer, must push the previous value
first.</p>
</li>
<li>
<p>The callee may then access its parameters relative to <code>EBP</code>.
The doubleword at <code>[EBP]</code> holds the previous value of
<code>EBP</code> as it was pushed; the next doubleword, at
<code>[EBP+4]</code>, holds the return address, pushed implicitly by
<code>CALL</code>. The parameters start after that, at
<code>[EBP+8]</code>. The leftmost parameter of the function, since it was
pushed last, is accessible at this offset from <code>EBP</code>; the others
follow, at successively greater offsets. Thus, in a function such as
<code>printf</code> which takes a variable number of parameters, the
pushing of the parameters in reverse order means that the function knows
where to find its first parameter, which tells it the number and type of
the remaining ones.</p>
</li>
<li>
<p>The callee may also wish to decrease <code>ESP</code> further, so as to
allocate space on the stack for local variables, which will then be
accessible at negative offsets from <code>EBP</code>.</p>
</li>
<li>
<p>The callee, if it wishes to return a value to the caller, should leave
the value in <code>AL</code>, <code>AX</code> or <code>EAX</code> depending
on the size of the value. Floating-point results are typically returned in
<code>ST0</code>.</p>
</li>
<li>
<p>Once the callee has finished processing, it restores <code>ESP</code>
from <code>EBP</code> if it had allocated local stack space, then pops the
previous value of <code>EBP</code>, and returns via <code>RET</code>
(equivalently, <code>RETN</code>).</p>
</li>
<li>
<p>When the caller regains control from the callee, the function parameters
are still on the stack, so it typically adds an immediate constant to
<code>ESP</code> to remove them (instead of executing a number of slow
<code>POP</code> instructions). Thus, if a function is accidentally called
with the wrong number of parameters due to a prototype mismatch, the stack
will still be returned to a sensible state since the caller, which
<em>knows</em> how many parameters it pushed, does the removing.</p>
</li>
</ul>
<p>There is an alternative calling convention used by Win32 programs for
Windows API calls, and also for functions called <em>by</em> the Windows
API such as window procedures: they follow what Microsoft calls the
<code>__stdcall</code> convention. This is slightly closer to the Pascal
convention, in that the callee clears the stack by passing a parameter to
the <code>RET</code> instruction. However, the parameters are still pushed
in right-to-left order.</p>
<p>Thus, you would define a function in C style in the following way:</p>
<pre>
global  _myfunc 

_myfunc: 
        push    ebp 
        mov     ebp,esp 
        sub     esp,0x40        ; 64 bytes of local stack space 
        mov     ebx,[ebp+8]     ; first parameter to function 

        ; some more code 

        leave                   ; mov esp,ebp / pop ebp 
        ret
</pre>
<p>At the other end of the process, to call a C function from your assembly
code, you would do something like this:</p>
<pre>
extern  _printf 

        ; and then, further down... 

        push    dword [myint]   ; one of my integer variables 
        push    dword mystring  ; pointer into my data segment 
        call    _printf 
        add     esp,byte 8      ; `byte' saves space 

        ; then those data items... 

segment _DATA 

myint       dd   1234 
mystring    db   'This number -&gt; %d &lt;- should be 1234',10,0
</pre>
<p>This piece of code is the assembly equivalent of the C code</p>
<pre>
    int myint = 1234; 
    printf("This number -&gt; %d &lt;- should be 1234\n", myint);
</pre>
<h4 id="section-10.1.3">10.1.3 Accessing Data Items</h4>
<p>To get at the contents of C variables, or to declare variables which C
can access, you need only declare the names as <code>GLOBAL</code> or
<code>EXTERN</code>. (Again, the names require leading underscores, as
stated in <a href="#section-10.1.1">section 10.1.1</a>.) Thus, a C variable
declared as <code>int i</code> can be accessed from assembler as</p>
<pre>
          extern _i 
          mov eax,[_i]
</pre>
<p>And to declare your own integer variable which C programs can access as
<code>extern int j</code>, you do this (making sure you are assembling in
the <code>_DATA</code> segment, if necessary):</p>
<pre>
          global _j 
_j        dd 0
</pre>
<p>To access a C array, you need to know the size of the components of the
array. For example, <code>int</code> variables are four bytes long, so if a
C program declares an array as <code>int a[10]</code>, you can access
<code>a[3]</code> by coding <code>mov ax,[_a+12]</code>. (The byte offset
12 is obtained by multiplying the desired array index, 3, by the size of
the array element, 4.) The sizes of the C base types in 32-bit compilers
are: 1 for <code>char</code>, 2 for <code>short</code>, 4 for
<code>int</code>, <code>long</code> and <code>float</code>, and 8 for
<code>double</code>. Pointers, being 32-bit addresses, are also 4 bytes
long.</p>
<p>To access a C data structure, you need to know the offset from the base
of the structure to the field you are interested in. You can either do this
by converting the C structure definition into a NASM structure definition
(using <code>STRUC</code>), or by calculating the one offset and using just
that.</p>
<p>To do either of these, you should read your C compiler's manual to find
out how it organizes data structures. NASM gives no special alignment to
structure members in its own <code>STRUC</code> macro, so you have to
specify alignment yourself if the C compiler generates it. Typically, you
might find that a structure like</p>
<pre>
struct { 
    char c; 
    int i; 
} foo;
</pre>
<p>might be eight bytes long rather than five, since the <code>int</code>
field would be aligned to a four-byte boundary. However, this sort of
feature is sometimes a configurable option in the C compiler, either using
command-line options or <code>#pragma</code> lines, so you have to find out
how your own compiler does it.</p>
<h4 id="section-10.1.4">10.1.4 <code>c32.mac</code>: Helper Macros for the 32-bit C Interface</h4>
<p>Included in the NASM archives, in the <code>misc</code> directory, is a
file <code>c32.mac</code> of macros. It defines three macros:
<code>proc</code>, <code>arg</code> and <code>endproc</code>. These are
intended to be used for C-style procedure definitions, and they automate a
lot of the work involved in keeping track of the calling convention.</p>
<p>An example of an assembly function using the macro set is given here:</p>
<pre>
proc    _proc32 

%$i     arg 
%$j     arg 
        mov     eax,[ebp + %$i] 
        mov     ebx,[ebp + %$j] 
        add     eax,[ebx] 

endproc
</pre>
<p>This defines <code>_proc32</code> to be a procedure taking two
arguments, the first (<code>i</code>) an integer and the second
(<code>j</code>) a pointer to an integer. It returns <code>i + *j</code>.</p>
<p>Note that the <code>arg</code> macro has an <code>EQU</code> as the
first line of its expansion, and since the label before the macro call gets
prepended to the first line of the expanded macro, the <code>EQU</code>
works, defining <code>%$i</code> to be an offset from <code>BP</code>. A
context-local variable is used, local to the context pushed by the
<code>proc</code> macro and popped by the <code>endproc</code> macro, so
that the same argument name can be used in later procedures. Of course, you
don't <em>have</em> to do that.</p>
<p><code>arg</code> can take an optional parameter, giving the size of the
argument. If no size is given, 4 is assumed, since it is likely that many
function parameters will be of type <code>int</code> or pointers.</p>
<h3 id="section-10.2">10.2 Writing NetBSD/FreeBSD/OpenBSD and Linux/ELF Shared Libraries</h3>
<p><code>ELF</code> replaced the older <code>a.out</code> object file
format under Linux because it contains support for position-independent
code (PIC), which makes writing shared libraries much easier. NASM supports
the <code>ELF</code> position-independent code features, so you can write
Linux <code>ELF</code> shared libraries in NASM.</p>
<p>NetBSD, and its close cousins FreeBSD and OpenBSD, take a different
approach by hacking PIC support into the <code>a.out</code> format. NASM
supports this as the <code>aoutb</code> output format, so you can write BSD
shared libraries in NASM too.</p>
<p>The operating system loads a PIC shared library by memory-mapping the
library file at an arbitrarily chosen point in the address space of the
running process. The contents of the library's code section must therefore
not depend on where it is loaded in memory.</p>
<p>Therefore, you cannot get at your variables by writing code like this:</p>
<pre>
        mov     eax,[myvar]             ; WRONG
</pre>
<p>Instead, the linker provides an area of memory called the <em>global
offset table</em>, or GOT; the GOT is situated at a constant distance from
your library's code, so if you can find out where your library is loaded
(which is typically done using a <code>CALL</code> and <code>POP</code>
combination), you can obtain the address of the GOT, and you can then load
the addresses of your variables out of linker-generated entries in the GOT.</p>
<p>The <em>data</em> section of a PIC shared library does not have these
restrictions: since the data section is writable, it has to be copied into
memory anyway rather than just paged in from the library file, so as long
as it's being copied it can be relocated too. So you can put ordinary types
of relocation in the data section without too much worry (but see
<a href="#section-10.2.4">section 10.2.4</a> for a caveat).</p>
<h4 id="section-10.2.1">10.2.1 Obtaining the Address of the GOT</h4>
<p>Each code module in your shared library should define the GOT as an
external symbol:</p>
<pre>
extern  _GLOBAL_OFFSET_TABLE_   ; in ELF 
extern  __GLOBAL_OFFSET_TABLE_  ; in BSD a.out
</pre>
<p>At the beginning of any function in your shared library which plans to
access your data or BSS sections, you must first calculate the address of
the GOT. This is typically done by writing the function in this form:</p>
<pre>
func:   push    ebp 
        mov     ebp,esp 
        push    ebx 
        call    .get_GOT 
.get_GOT: 
        pop     ebx 
        add     ebx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc 

        ; the function body comes here 

        mov     ebx,[ebp-4] 
        mov     esp,ebp 
        pop     ebp 
        ret
</pre>
<p>(For BSD, again, the symbol <code>_GLOBAL_OFFSET_TABLE</code> requires a
second leading underscore.)</p>
<p>The first two lines of this function are simply the standard C prologue
to set up a stack frame, and the last three lines are standard C function
epilogue. The third line, and the fourth to last line, save and restore the
<code>EBX</code> register, because PIC shared libraries use this register
to store the address of the GOT.</p>
<p>The interesting bit is the <code>CALL</code> instruction and the
following two lines. The <code>CALL</code> and <code>POP</code> combination
obtains the address of the label <code>.get_GOT</code>, without having to
know in advance where the program was loaded (since the <code>CALL</code>
instruction is encoded relative to the current position). The
<code>ADD</code> instruction makes use of one of the special PIC relocation
types: GOTPC relocation. With the <code>WRT ..gotpc</code> qualifier
specified, the symbol referenced (here <code>_GLOBAL_OFFSET_TABLE_</code>,
the special symbol assigned to the GOT) is given as an offset from the
beginning of the section. (Actually, <code>ELF</code> encodes it as the
offset from the operand field of the <code>ADD</code> instruction, but NASM
simplifies this deliberately, so you do things the same way for both
<code>ELF</code> and <code>BSD</code>.) So the instruction then
<em>adds</em> the beginning of the section, to get the real address of the
GOT, and subtracts the value of <code>.get_GOT</code> which it knows is in
<code>EBX</code>. Therefore, by the time that instruction has finished,
<code>EBX</code> contains the address of the GOT.</p>
<p>If you didn't follow that, don't worry: it's never necessary to obtain
the address of the GOT by any other means, so you can put those three
instructions into a macro and safely ignore them:</p>
<pre>
%macro  get_GOT 0 

        call    %%getgot 
  %%getgot: 
        pop     ebx 
        add     ebx,_GLOBAL_OFFSET_TABLE_+$$-%%getgot wrt ..gotpc 

%endmacro
</pre>
<h4 id="section-10.2.2">10.2.2 Finding Your Local Data Items</h4>
<p>Having got the GOT, you can then use it to obtain the addresses of your
data items. Most variables will reside in the sections you have declared;
they can be accessed using the <code>..gotoff</code> special
<code>WRT</code> type. The way this works is like this:</p>
<pre>
        lea     eax,[ebx+myvar wrt ..gotoff]
</pre>
<p>The expression <code>myvar wrt ..gotoff</code> is calculated, when the
shared library is linked, to be the offset to the local variable
<code>myvar</code> from the beginning of the GOT. Therefore, adding it to
<code>EBX</code> as above will place the real address of <code>myvar</code>
in <code>EAX</code>.</p>
<p>If you declare variables as <code>GLOBAL</code> without specifying a
size for them, they are shared between code modules in the library, but do
not get exported from the library to the program that loaded it. They will
still be in your ordinary data and BSS sections, so you can access them in
the same way as local variables, using the above <code>..gotoff</code>
mechanism.</p>
<p>Note that due to a peculiarity of the way BSD <code>a.out</code> format
handles this relocation type, there must be at least one non-local symbol
in the same section as the address you're trying to access.</p>
<h4 id="section-10.2.3">10.2.3 Finding External and Common Data Items</h4>
<p>If your library needs to get at an external variable (external to the
<em>library</em>, not just to one of the modules within it), you must use
the <code>..got</code> type to get at it. The <code>..got</code> type,
instead of giving you the offset from the GOT base to the variable, gives
you the offset from the GOT base to a GOT <em>entry</em> containing the
address of the variable. The linker will set up this GOT entry when it
builds the library, and the dynamic linker will place the correct address
in it at load time. So to obtain the address of an external variable
<code>extvar</code> in <code>EAX</code>, you would code</p>
<pre>
        mov     eax,[ebx+extvar wrt ..got]
</pre>
<p>This loads the address of <code>extvar</code> out of an entry in the
GOT. The linker, when it builds the shared library, collects together every
relocation of type <code>..got</code>, and builds the GOT so as to ensure
it has every necessary entry present.</p>
<p>Common variables must also be accessed in this way.</p>
<h4 id="section-10.2.4">10.2.4 Exporting Symbols to the Library User</h4>
<p>If you want to export symbols to the user of the library, you have to
declare whether they are functions or data, and if they are data, you have
to give the size of the data item. This is because the dynamic linker has
to build procedure linkage table entries for any exported functions, and
also moves exported data items away from the library's data section in
which they were declared.</p>
<p>So to export a function to users of the library, you must use</p>
<pre>
global  func:function           ; declare it as a function 

func:   push    ebp 

        ; etc.
</pre>
<p>And to export a data item such as an array, you would have to code</p>
<pre>
global  array:data array.end-array      ; give the size too 

array:  resd    128 
.end:
</pre>
<p>Be careful: If you export a variable to the library user, by declaring
it as <code>GLOBAL</code> and supplying a size, the variable will end up
living in the data section of the main program, rather than in your
library's data section, where you declared it. So you will have to access
your own global variable with the <code>..got</code> mechanism rather than
<code>..gotoff</code>, as if it were external (which, effectively, it has
become).</p>
<p>Equally, if you need to store the address of an exported global in one
of your data sections, you can't do it by means of the standard sort of
code:</p>
<pre>
dataptr:        dd      global_data_item        ; WRONG
</pre>
<p>NASM will interpret this code as an ordinary relocation, in which
<code>global_data_item</code> is merely an offset from the beginning of the
<code>.data</code> section (or whatever); so this reference will end up
pointing at your data section instead of at the exported global which
resides elsewhere.</p>
<p>Instead of the above code, then, you must write</p>
<pre>
dataptr:        dd      global_data_item wrt ..sym
</pre>
<p>which makes use of the special <code>WRT</code> type <code>..sym</code>
to instruct NASM to search the symbol table for a particular symbol at that
address, rather than just relocating by section base.</p>
<p>Either method will work for functions: referring to one of your
functions by means of</p>
<pre>
funcptr:        dd      my_function
</pre>
<p>will give the user the address of the code you wrote, whereas</p>
<pre>
funcptr:        dd      my_function wrt ..sym
</pre>
<p>will give the address of the procedure linkage table for the function,
which is where the calling program will <em>believe</em> the function
lives. Either address is a valid way to call the function.</p>
<h4 id="section-10.2.5">10.2.5 Calling Procedures Outside the Library</h4>
<p>Calling procedures outside your shared library has to be done by means
of a <em>procedure linkage table</em>, or PLT. The PLT is placed at a known
offset from where the library is loaded, so the library code can make calls
to the PLT in a position-independent way. Within the PLT there is code to
jump to offsets contained in the GOT, so function calls to other shared
libraries or to routines in the main program can be transparently passed
off to their real destinations.</p>
<p>To call an external routine, you must use another special PIC relocation
type, <code>WRT ..plt</code>. This is much easier than the GOT-based ones:
you simply replace calls such as <code>CALL printf</code> with the
PLT-relative version <code>CALL printf WRT ..plt</code>.</p>
<h4 id="section-10.2.6">10.2.6 Generating the Library File</h4>
<p>Having written some code modules and assembled them to <code>.o</code>
files, you then generate your shared library with a command such as</p>
<pre>
ld -shared -o library.so module1.o module2.o       # for ELF 
ld -Bshareable -o library.so module1.o module2.o   # for BSD
</pre>
<p>For ELF, if your shared library is going to reside in system directories
such as <code>/usr/lib</code> or <code>/lib</code>, it is usually worth
using the <code>-soname</code> flag to the linker, to store the final
library file name, with a version number, into the library:</p>
<pre>
ld -shared -soname library.so.1 -o library.so.1.2 *.o
</pre>
<p>You would then copy <code>library.so.1.2</code> into the library
directory, and create <code>library.so.1</code> as a symbolic link to it.</p>
</div>
</body>
</html>
