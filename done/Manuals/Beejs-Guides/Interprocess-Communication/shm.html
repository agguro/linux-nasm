<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej's Guide to Interprocess Communication</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&display=swap" rel="stylesheet"> 

  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }

  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }

  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }

  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }

  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }


  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }

  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }

  td {
      vertical-align: top;
  }

  body {
      font-size: 12pt;
      max-width: 43em;
  }

  figure {
      text-align: center;
  }
  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->

  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div style="text-align:center"><span><a href="semaphores.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="mmap.html">Next</a></span></div><hr>
<h1 data-number="9" id="shm"><span class="header-section-number">9</span> Shared Memory Segments</h1>
<p>The cool thing about shared memory segments is that they are what they sound like: a segment of memory that is shared between processes. I mean, think of the potential of this! You could allocate a block of player information for a multi-player game and have each process access it at will! Fun, fun, fun. (Of course, memory-mapped files accomplish the same thing and have the added advantage of persistence, albeit with the same caveats that apply to shared memory.)</p>
<p>There are, as usual, more gotchas to watch out for, but itâ€™s all pretty easy in the long run. See, you just connect to the shared memory segment, and get a pointer to the memory. You can read and write to this pointer and all changes you make will be visible to everyone else connected to the segment. There is nothing simpler. Well, there is, actually, but I was just trying to make you more comfortable.</p>
<h2 data-number="9.1" id="creating-the-segment-and-connecting"><span class="header-section-number">9.1</span> Creating the segment and connecting</h2>
<p>Similarly to other forms of System V IPC, a shared memory segment is created and connected to via the <code>shmget()</code> call:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="shm.html#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shmget<span class="op">(</span>key_t key<span class="op">,</span> <span class="dt">size_t</span> size<span class="op">,</span> <span class="dt">int</span> shmflg<span class="op">);</span></span></code></pre></div>
<p>Upon successful completion, <code>shmget()</code> returns an identifier for the shared memory segment. The <code>key</code> argument should be created the same was as shown in the <a href="mq.html#mqftok">Message Queues</a> document, using <code>ftok()</code>. The next argument, <code>size</code>, is the size in bytes of the shared memory segment. Finally, the <code>shmflg</code> should be set to the permissions of the segment bitwise-ORâ€™d with <code>IPC_CREAT</code> if you want to create the segment, but can be <code>0</code> otherwise. (It doesnâ€™t hurt to specify <code>IPC_CREAT</code> every timeâ€”it will simply connect you if the segment already exists.)</p>
<p>Hereâ€™s an example call that creates a 1K segment with <code>644</code> permissions (<code>rw-r--r--</code>):</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="shm.html#cb51-1" aria-hidden="true" tabindex="-1"></a>key_t key<span class="op">;</span></span>
<span id="cb51-2"><a href="shm.html#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shmid<span class="op">;</span></span>
<span id="cb51-3"><a href="shm.html#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="shm.html#cb51-4" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> ftok<span class="op">(</span><span class="st">&quot;/home/beej/somefile3&quot;</span><span class="op">,</span> <span class="ch">&#39;R&#39;</span><span class="op">);</span></span>
<span id="cb51-5"><a href="shm.html#cb51-5" aria-hidden="true" tabindex="-1"></a>shmid <span class="op">=</span> shmget<span class="op">(</span>key<span class="op">,</span> <span class="dv">1024</span><span class="op">,</span> <span class="bn">0644</span> <span class="op">|</span> IPC_CREAT<span class="op">);</span></span></code></pre></div>
<p>(It may not be possible to actually create a 1K segment, as the operating system is allowed to increase the size to fit any internal constraints it may have. For example, on a system with 4K virtual pages, itâ€™s likely the size will be increased to 4K. Of course, your program wonâ€™t know or care; this is just an implementation detail.)</p>
<p>But how do you get a pointer to that data from the <code>shmid</code> handle? The answer is in the call <code>shmat()</code>, in the following section.</p>
<h2 data-number="9.2" id="attach-megetting-a-pointer-to-the-segment"><span class="header-section-number">9.2</span> Attach meâ€”getting a pointer to the segment</h2>
<p>Before you can use a shared memory segment, you have to attach yourself to it using the <code>shmat()</code> call:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="shm.html#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>shmat<span class="op">(</span><span class="dt">int</span> `shmid`<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>`shmaddr`<span class="op">,</span> <span class="dt">int</span> `shmflg`<span class="op">);</span></span></code></pre></div>
<p>What does it all mean? Well, <code>shmid</code> is the shared memory ID you got from the call to <code>shmget()</code>. Next is <code>shmaddr</code>, which you can use to tell <code>shmat()</code> which specific address to use but you should just set it to <code>0</code> and let the OS choose the address for you. Finally, the <code>shmflg</code> can be set to <code>SHM_RDONLY</code> if you only want to read from it, <code>0</code> otherwise. (Check the man pages for other useful flags that can be included.)</p>
<p>Hereâ€™s a more complete example of how to get a pointer to a shared memory segment:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="shm.html#cb53-1" aria-hidden="true" tabindex="-1"></a>key_t key<span class="op">;</span></span>
<span id="cb53-2"><a href="shm.html#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shmid<span class="op">;</span></span>
<span id="cb53-3"><a href="shm.html#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb53-4"><a href="shm.html#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="shm.html#cb53-5" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> ftok<span class="op">(</span><span class="st">&quot;/home/beej/somefile3&quot;</span><span class="op">,</span> <span class="ch">&#39;R&#39;</span><span class="op">);</span></span>
<span id="cb53-6"><a href="shm.html#cb53-6" aria-hidden="true" tabindex="-1"></a>shmid <span class="op">=</span> shmget<span class="op">(</span>key<span class="op">,</span> <span class="dv">1024</span><span class="op">,</span> <span class="bn">0644</span> <span class="op">|</span> IPC_CREAT<span class="op">);</span></span>
<span id="cb53-7"><a href="shm.html#cb53-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> shmat<span class="op">(</span>shmid<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);&lt;/</span>code<span class="op">&gt;</span></span></code></pre></div>
<p>And <em>bammo</em>! You have the pointer to the shared memory segment! Notice that <code>shmat()</code> returns a <code>void</code> pointer, and weâ€™re treating it, in this case, as a <code>char</code> pointer. You can treat it as anything you like, depending on what kind of data you have in there. Pointers to arrays of structures are just as acceptable as anything else.</p>
<p>Also, itâ€™s interesting to note that <code>shmat()</code> returns <code>-1</code> on failure (as does <code>mmap()</code>). But how do you get <code>-1</code> in a <code>void</code> pointer? Just do a cast during the comparison to check for errors:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="shm.html#cb54-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> shmat<span class="op">(</span>shmid<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb54-2"><a href="shm.html#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>data <span class="op">==</span> MAP_FAILED<span class="op">)</span></span>
<span id="cb54-3"><a href="shm.html#cb54-3" aria-hidden="true" tabindex="-1"></a>    perror<span class="op">(</span><span class="st">&quot;shmat&quot;</span><span class="op">);</span></span></code></pre></div>
<p>(Itâ€™s important to note that the integer is being cast to a pointer, and not the pointer return value being cast to an integer. Itâ€™s a subtle difference, but the latter is not always portable between architectures. Also note that the cast is to <code>void*</code> and not <code>char*</code>, as you might expect. Since the language guarantees that implicit casts from <code>void*</code> to any other kind of pointer are always safe and reliable, itâ€™s better to use <code>void*</code> and let the compiler to the work.)</p>
<p>All you have to do now is change the data it points to normal pointer-style. There are some samples in the next section.</p>
<h2 data-number="9.3" id="reading-and-writing"><span class="header-section-number">9.3</span> Reading and Writing</h2>
<p>Lets say you have the <code>data</code> pointer from the above example. It is a <code>char</code> pointer, so weâ€™ll be reading and writing chars from it. Furthermore, for the sake of simplicity, lets say the 1K shared memory segment contains a null-terminated string.</p>
<p>It couldnâ€™t be easier. Since itâ€™s just a string in there, we can print it like this:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="shm.html#cb55-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;shared contents: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> data<span class="op">);</span></span></code></pre></div>
<p>And we could store something in it as easily as this:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="shm.html#cb56-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter a string: &quot;</span><span class="op">);</span></span>
<span id="cb56-2"><a href="shm.html#cb56-2" aria-hidden="true" tabindex="-1"></a>fgets<span class="op">(</span>data<span class="op">,</span> <span class="dv">1024</span><span class="op">,</span> stdin<span class="op">);</span></span></code></pre></div>
<p>Of course, like I said earlier, you can have other data in there besides just <code>char</code>s. Iâ€™m just using them as an example. Iâ€™ll just make the assumption that youâ€™re familiar enough with pointers in C that youâ€™ll be able to deal with whatever kind of data you stick in there.</p>
<h2 data-number="9.4" id="detaching-from-and-deleting-segments"><span class="header-section-number">9.4</span> Detaching from and deleting segments</h2>
<p>When youâ€™re done with the shared memory segment, your program should detach itself from it using the <code>shmdt()</code> call (if you donâ€™t, this will happen automatically when the process terminates):</p>
<pre class="{.c{"><code>int shmdt(void *`shmaddr`);</code></pre>
<p>The only argument, <code>shmaddr</code>, is the address you got from <code>shmat()</code>. The function returns <code>-1</code> on error, <code>0</code> on success.</p>
<p>When you detach from the segment, it isnâ€™t destroyed. Nor is it removed when <em>everyone</em> detaches from it. You have to specifically destroy it using a call to <code>shmctl()</code>, similar to the control calls for the other System V IPC functions:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="shm.html#cb58-1" aria-hidden="true" tabindex="-1"></a>shmctl<span class="op">(</span>shmid<span class="op">,</span> IPC_RMID<span class="op">,</span> NULL<span class="op">);</span></span></code></pre></div>
<p>The above call deletes the shared memory segment, assuming no one else is attached to it. The <code>shmctl()</code> function does a lot more than this, though, and is worth looking into. (On your own, of course, since this is only an overview!)</p>
<p>As always, you can destroy the shared memory segment from the command line using the <code>ipcrm</code> Unix command. Also, be sure that you donâ€™t leave any unused shared memory segments sitting around wasting system resources. All the System V IPC objects you own can be viewed using the <code>ipcs</code> command.</p>
<h2 data-number="9.5" id="shmcon"><span class="header-section-number">9.5</span> Concurrency</h2>
<p>What are concurrency issues? Well, since you have multiple processes modifying the shared memory segment, it is possible that certain errors could crop up when updates to the segment occur simultaneously. This <em>concurrent</em> access is almost always a problem when you have multiple writers to a shared object.</p>
<p>The way to get around this is to use <a href="semaphores.html#semaphores">Semaphores</a> to lock the shared memory segment while a process is writing to it. (Sometimes the lock will encompass both a read and write to the shared memory, depending on what youâ€™re doing.)</p>
<p>A true discussion of concurrency is beyond the scope of this paper, and you might want to check out the <a href="https://en.wikipedia.org/wiki/Concurrency">Wikipedia article on the matter</a><a href="footnotes.html#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a>. Iâ€™ll just leave it with this: if you start getting weird inconsistencies in your shared data when you connect two or more processes to it, you could very well have a concurrency problem.</p>
<h2 data-number="9.6" id="sample-code"><span class="header-section-number">9.6</span> Sample code</h2>
<p>Now that Iâ€™ve primed you on all the dangers of concurrent access to a shared memory segment without using semaphores, Iâ€™ll show you a demo that does just that. Since this isnâ€™t a mission-critical application, and itâ€™s unlikely that youâ€™ll be accessing the shared data at the same time as any other process, Iâ€™ll just leave the semaphores out for the sake of simplicity.</p>
<p>This program does one of two things: if you run it with no command line parameters, it prints the contents of the shared memory segment. If you give it one command line parameter, it stores that parameter in the shared memory segment.</p>
<p>Hereâ€™s the code for <a href="https://beej.us/guide/bgipc/source/examples/shmdemo.c"><code>shmdemo.c</code></a><a href="footnotes.html#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb59-1"><a href="shm.html#cb59-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb59-2"><a href="shm.html#cb59-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb59-3"><a href="shm.html#cb59-3"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb59-4"><a href="shm.html#cb59-4"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb59-5"><a href="shm.html#cb59-5"></a><span class="pp">#include </span><span class="im">&lt;sys/ipc.h&gt;</span></span>
<span id="cb59-6"><a href="shm.html#cb59-6"></a><span class="pp">#include </span><span class="im">&lt;sys/shm.h&gt;</span></span>
<span id="cb59-7"><a href="shm.html#cb59-7"></a></span>
<span id="cb59-8"><a href="shm.html#cb59-8"></a><span class="pp">#define SHM_SIZE </span><span class="dv">1024</span><span class="pp">  </span><span class="co">/* make it a 1K shared memory segment */</span></span>
<span id="cb59-9"><a href="shm.html#cb59-9"></a></span>
<span id="cb59-10"><a href="shm.html#cb59-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb59-11"><a href="shm.html#cb59-11"></a><span class="op">{</span></span>
<span id="cb59-12"><a href="shm.html#cb59-12"></a>    key_t key<span class="op">;</span></span>
<span id="cb59-13"><a href="shm.html#cb59-13"></a>    <span class="dt">int</span> shmid<span class="op">;</span></span>
<span id="cb59-14"><a href="shm.html#cb59-14"></a>    <span class="dt">char</span> <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb59-15"><a href="shm.html#cb59-15"></a>    <span class="dt">int</span> mode<span class="op">;</span></span>
<span id="cb59-16"><a href="shm.html#cb59-16"></a></span>
<span id="cb59-17"><a href="shm.html#cb59-17"></a>    <span class="cf">if</span> <span class="op">(</span>argc <span class="op">&gt;</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-18"><a href="shm.html#cb59-18"></a>            fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;usage: shmdemo [data_to_write]</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb59-19"><a href="shm.html#cb59-19"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb59-20"><a href="shm.html#cb59-20"></a>    <span class="op">}</span></span>
<span id="cb59-21"><a href="shm.html#cb59-21"></a></span>
<span id="cb59-22"><a href="shm.html#cb59-22"></a>    <span class="co">/* make the key: */</span></span>
<span id="cb59-23"><a href="shm.html#cb59-23"></a>    <span class="cf">if</span> <span class="op">((</span>key <span class="op">=</span> ftok<span class="op">(</span><span class="st">&quot;shmdemo.c&quot;</span><span class="op">,</span> <span class="ch">&#39;R&#39;</span><span class="op">))</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-24"><a href="shm.html#cb59-24"></a>            perror<span class="op">(</span><span class="st">&quot;ftok&quot;</span><span class="op">);</span></span>
<span id="cb59-25"><a href="shm.html#cb59-25"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb59-26"><a href="shm.html#cb59-26"></a>    <span class="op">}</span></span>
<span id="cb59-27"><a href="shm.html#cb59-27"></a></span>
<span id="cb59-28"><a href="shm.html#cb59-28"></a>    <span class="co">/* connect to (and possibly create) the segment: */</span></span>
<span id="cb59-29"><a href="shm.html#cb59-29"></a>    <span class="cf">if</span> <span class="op">((</span>shmid <span class="op">=</span> shmget<span class="op">(</span>key<span class="op">,</span> SHM_SIZE<span class="op">,</span> <span class="bn">0644</span> <span class="op">|</span> IPC_CREAT<span class="op">))</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-30"><a href="shm.html#cb59-30"></a>            perror<span class="op">(</span><span class="st">&quot;shmget&quot;</span><span class="op">);</span></span>
<span id="cb59-31"><a href="shm.html#cb59-31"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb59-32"><a href="shm.html#cb59-32"></a>    <span class="op">}</span></span>
<span id="cb59-33"><a href="shm.html#cb59-33"></a></span>
<span id="cb59-34"><a href="shm.html#cb59-34"></a>    <span class="co">/* attach to the segment to get a pointer to it: */</span></span>
<span id="cb59-35"><a href="shm.html#cb59-35"></a>    data <span class="op">=</span> shmat<span class="op">(</span>shmid<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb59-36"><a href="shm.html#cb59-36"></a></span>
<span id="cb59-37"><a href="shm.html#cb59-37"></a>    <span class="co">/* we _could_ use MAP_FAILED, but technically that&#39;s not */</span></span>
<span id="cb59-38"><a href="shm.html#cb59-38"></a>    <span class="co">/* the defined return value. System V failed on this one! */</span></span>
<span id="cb59-39"><a href="shm.html#cb59-39"></a>    <span class="cf">if</span> <span class="op">(</span>data <span class="op">==</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)(-</span><span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb59-40"><a href="shm.html#cb59-40"></a>            perror<span class="op">(</span><span class="st">&quot;shmat&quot;</span><span class="op">);</span></span>
<span id="cb59-41"><a href="shm.html#cb59-41"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb59-42"><a href="shm.html#cb59-42"></a>    <span class="op">}</span></span>
<span id="cb59-43"><a href="shm.html#cb59-43"></a></span>
<span id="cb59-44"><a href="shm.html#cb59-44"></a>    <span class="co">/* read or modify the segment, based on the command line: */</span></span>
<span id="cb59-45"><a href="shm.html#cb59-45"></a>    <span class="cf">if</span> <span class="op">(</span>argc <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-46"><a href="shm.html#cb59-46"></a>            printf<span class="op">(</span><span class="st">&quot;writing to segment: </span><span class="sc">\&quot;%s\&quot;\n</span><span class="st">&quot;</span><span class="op">,</span> argv<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb59-47"><a href="shm.html#cb59-47"></a>            strncpy<span class="op">(</span>data<span class="op">,</span> argv<span class="op">[</span><span class="dv">1</span><span class="op">],</span> SHM_SIZE<span class="op">);</span></span>
<span id="cb59-48"><a href="shm.html#cb59-48"></a>            data<span class="op">[</span>SHM_SIZE<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb59-49"><a href="shm.html#cb59-49"></a>    <span class="op">}</span> <span class="cf">else</span></span>
<span id="cb59-50"><a href="shm.html#cb59-50"></a>            printf<span class="op">(</span><span class="st">&quot;segment contains: </span><span class="sc">\&quot;%s\&quot;\n</span><span class="st">&quot;</span><span class="op">,</span> data<span class="op">);</span></span>
<span id="cb59-51"><a href="shm.html#cb59-51"></a></span>
<span id="cb59-52"><a href="shm.html#cb59-52"></a>    <span class="co">/* detach from the segment: */</span></span>
<span id="cb59-53"><a href="shm.html#cb59-53"></a>    <span class="cf">if</span> <span class="op">(</span>shmdt<span class="op">(</span>data<span class="op">)</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-54"><a href="shm.html#cb59-54"></a>            perror<span class="op">(</span><span class="st">&quot;shmdt&quot;</span><span class="op">);</span></span>
<span id="cb59-55"><a href="shm.html#cb59-55"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb59-56"><a href="shm.html#cb59-56"></a>    <span class="op">}</span></span>
<span id="cb59-57"><a href="shm.html#cb59-57"></a></span>
<span id="cb59-58"><a href="shm.html#cb59-58"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb59-59"><a href="shm.html#cb59-59"></a><span class="op">}</span></span></code></pre></div>
<p>More commonly, a process will attach to the segment and run for a bit while other programs are changing and reading the shared segment. Itâ€™s neat to watch one process update the segment and see the changes appear to other processes. Again, for simplicity, the sample code doesnâ€™t do that, but you can see how the data is shared between independent processes.</p>
<p>Also, thereâ€™s no code in here for removing the segmentâ€”be sure to do that when youâ€™re done messing with it.</p>
<!-- Beej's guide to IPC

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<!-- ======================================================= -->
<!-- Memory Mapped Files -->
<!-- ======================================================= -->
<hr><div style="text-align:center"><span><a href="semaphores.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="mmap.html">Next</a></span></div></body>
</html>
