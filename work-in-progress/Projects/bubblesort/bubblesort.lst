     1                                  ;name:         bubblesort.asm
     2                                  ;
     3                                  ;description:  Demonstration of the BubbleSort Algorithm, with or without optimzing steps.
     4                                  ;              The program needs to be re-assembled and linked when changing to an
     5                                  ;              optimization step.
     6                                  ;              source : https://en.wikipedia.org/wiki/Bubble_sort
     7                                  ;
     8                                  ;build:        nasm "-felf64" bubblesort.asm -l bubblesort.lst -o bubblesort.o
     9                                  ;              ld -s -melf_x86_64 -o bubblesort bubblesort.o
    10                                  
    11                                  
    12                                  bits 64
    13                                  
    14                                  [list -]
    17                                  
    18                                  ; here you can choose between the 3 different steps of optimization
    19                                  ; O : [default] no optimization
    20                                  ; 1 : n-th pass finds the n-th largest elements
    21                                  ; 2 : no check after last swap
    22                                  
    23                                  %define OPTIMIZE_STEP 2
    24                                  
    25                                  %define TRUE      1
    26                                  %define FALSE     0
    27                                  
    28                                  %macro STRING 1
    29                                      .start:     db %1
    30                                      .length:    equ $-.start
    31                                  %endmacro
    32                                  
    33                                  %macro ARRAY 1-*
    34                                      %rep  %0
    35                                           dq  %1
    36                                           %rotate 1
    37                                      %endrep 
    38                                  %endmacro
    39                                  
    40                                  section .bss
    41                                  ; 64 bit integers have a range of -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    42                                  ; both included, so we need a buffer of 20 bytes at least to store them
    43                                  Buffer:
    44 00000000 ??                          sign           resb      1              ; ascii sign
    45 00000001 <res 13h>                   decimal        resb     19              ; 20 bytes to store a 64 bits number + sign
    46                                  
    47                                  section .data
    48                                  
    49                                  ; The list is intentionally sorted in descending order to demonstrate the wurst case scenario
    50                                  ; and determine the swaps and iterations.
    51                                  
    52                                      datasize:      equ       8   
    53                                      array:         ARRAY     154,2144,119,98,4,520,2, 75, 15, 0, -85,-4, -78,-54, -485,-458,-25, -92,-233,720,368,547,758,8, -233,72,-36,854,-775,807
    53                              <1>  array: 
    34                              <1>  %rep %0
    35                              <1>  dq %1
    36                              <1>  %rotate 1
    37                              <1>  %endrep
    35 00000000 9A00000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000008 6008000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000010 7700000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000018 6200000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000020 0400000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000028 0802000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000030 0200000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000038 4B00000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000040 0F00000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000048 0000000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000050 ABFFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000058 FCFFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000060 B2FFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000068 CAFFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000070 1BFEFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000078 36FEFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000080 E7FFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000088 A4FFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000090 17FFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 00000098 D002000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000A0 7001000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000A8 2302000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000B0 F602000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000B8 0800000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000C0 17FFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000C8 4800000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000D0 DCFFFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000D8 5603000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000E0 F9FCFFFFFFFFFFFF    <2>  dq %1
    36                              <2>  %rotate 1
    35 000000E8 2703000000000000    <2>  dq %1
    36                              <2>  %rotate 1
    54                                      .length        equ       ($-array)/datasize
    55                                  
    56                                      title:         STRING    {"Bubblesort Algorithm - Agguro 2012",10}
    56                              <1>  title: 
    29 000000F0 427562626C65736F72- <1>  .start: db %1
    29 000000F9 7420416C676F726974- <1>
    29 00000102 686D202D2041676775- <1>
    29 0000010B 726F20323031320A    <1>
    30                              <1>  .length: equ $-.start
    57                                  
    58                                  %if OPTIMIZE_STEP == 0
    59                                      opt0:          STRING    {"Optimization step: no optimization",10}
    60                                  %endif
    61                                  %if OPTIMIZE_STEP == 1
    62                                      opt1:          STRING    {"Optimization step: n-th pass finds the n-th largest elements",10}
    63                                  %endif
    64                                  %if OPTIMIZE_STEP == 2
    65                                      opt2:          STRING    {"Optimization step: no check after last swap",10}
    65                              <1>  opt2: 
    29 00000113 4F7074696D697A6174- <1>  .start: db %1
    29 0000011C 696F6E20737465703A- <1>
    29 00000125 206E6F20636865636B- <1>
    29 0000012E 206166746572206C61- <1>
    29 00000137 737420737761700A    <1>
    30                              <1>  .length: equ $-.start
    66                                  %endif
    67                                  
    68                                      unsorted:      STRING    {"The UNSORTED array:",10,"-------------------",10}
    68                              <1>  unsorted: 
    29 0000013F 54686520554E534F52- <1>  .start: db %1
    29 00000148 544544206172726179- <1>
    29 00000151 3A0A2D2D2D2D2D2D2D- <1>
    29 0000015A 2D2D2D2D2D2D2D2D2D- <1>
    29 00000163 2D2D2D0A            <1>
    30                              <1>  .length: equ $-.start
    69                                      sorted:        STRING    {10,"The SORTED array:",10,"-----------------",10}
    69                              <1>  sorted: 
    29 00000167 0A54686520534F5254- <1>  .start: db %1
    29 00000170 45442061727261793A- <1>
    29 00000179 0A2D2D2D2D2D2D2D2D- <1>
    29 00000182 2D2D2D2D2D2D2D2D2D- <1>
    29 0000018B 0A                  <1>
    30                              <1>  .length: equ $-.start
    70                                      iterations:    STRING    {10,"Number of iterations: "}
    70                              <1>  iterations: 
    29 0000018C 0A4E756D626572206F- <1>  .start: db %1
    29 00000195 662069746572617469- <1>
    29 0000019E 6F6E733A20          <1>
    30                              <1>  .length: equ $-.start
    71                                      swaps:         STRING    {"Number of swaps     : "}
    71                              <1>  swaps: 
    29 000001A3 4E756D626572206F66- <1>  .start: db %1
    29 000001AC 207377617073202020- <1>
    29 000001B5 20203A20            <1>
    30                              <1>  .length: equ $-.start
    72                                      lf:            STRING    {10}
    72                              <1>  lf: 
    29 000001B9 0A                  <1>  .start: db %1
    30                              <1>  .length: equ $-.start
    73                                       
    74                                  section .text
    75                                          global _start
    76                                       
    77                                  _start:
    78 00000000 9C                          pushfq
    79 00000001 50                          push      rax
    80 00000002 53                          push      rbx
    81 00000003 51                          push      rcx
    82 00000004 52                          push      rdx
    83 00000005 56                          push      rsi
    84 00000006 4151                        push      r9
    85 00000008 4150                        push      r8
    86                                  ; clear the screen and print title
    87                                  ; if the terminal you use don't support this, modify the bytes in .data
    88 0000000A 48BE-                       mov       rsi, title
    88 0000000C [F000000000000000] 
    89 00000014 BA23000000                  mov       rdx, title.length
    90 00000019 E8E6010000                  call      Print.string
    91                                  
    92                                      %if OPTIMIZE_STEP == 0
    93                                           mov       rsi, opt0
    94                                           mov       rdx, opt0.length
    95                                           call      Print.string
    96                                      %endif
    97                                      %if OPTIMIZE_STEP == 1
    98                                           mov       rsi, opt1
    99                                           mov       rdx, opt1.length
   100                                           call      Print.string
   101                                      %endif
   102                                      %if OPTIMIZE_STEP == 2
   103 0000001E 48BE-                            mov       rsi, opt2
   103 00000020 [1301000000000000] 
   104 00000028 BA2C000000                       mov       rdx, opt2.length
   105 0000002D E8D2010000                       call      Print.string
   106                                      %endif 
   107                                  
   108                                  ; display the unsorted Array on screen
   109 00000032 48BE-                       mov       rsi, unsorted
   109 00000034 [3F01000000000000] 
   110 0000003C BA28000000                  mov       rdx, unsorted.length
   111 00000041 E8BE010000                  call      Print.string
   112                                  ; print the Array elements
   113 00000046 E8D8000000                  call      ShowArray
   114                                  
   115                                  ; Here the Bubblesort algorithm starts. Depending the value of OPTIMIZE_STEP an optimized or
   116                                  ; non-optimized version is included.
   117                                  
   118                                  %if OPTIMIZE_STEP == 0
   119                                      %include "optimizingstep0.asm"
   120                                  %endif
   121                                  %if OPTIMIZE_STEP == 1
   122                                      %include "optimizingstep1.asm"
   123                                  %endif
   124                                  %if OPTIMIZE_STEP == 2
   125                                      %include "optimizingstep2.asm"
   126                              <1> ; Name:         optimizingstep2.asm
   127                              <1> ;
   128                              <1> ; 2nd optimization step : no check after last swap
   129                              <1> ; 
   130                              <1> ; it can happen that more than one element is placed in their final position
   131                              <1> ; on a single pass. In particular, after every pass, all elements after the
   132                              <1> ; last swap are sorted, and do not need to be checked again. This allows us to
   133                              <1> ; skip over a lot of the elements, resulting in about a worst case 50% improvement
   134                              <1> ; in comparison count (though no improvement in swap counts), and adds very little
   135                              <1> ; complexity because the new code subsumes the "swapped" variable.
   136                              <1> ;
   137                              <1> ; source: http://en.wikipedia.org/wiki/Bubble_sort#Optimizing_bubble_sort
   138                              <1> 
   139                              <1> BubbleSort:
   140 0000004B 4D31C0              <1>      xor       r8,r8                         ; number of iterations
   141 0000004E 4D31C9              <1>      xor       r9,r9                         ; number of swaps (informative)
   142 00000051 41BA1E000000        <1>      mov       r10, array.length             ; r10 = n = arrayLength
   143                              <1> .repeat:
   144 00000057 41BB00000000        <1>      mov       r11, 0                        ; r11 = newn = 0     ADDED
   145 0000005D B901000000          <1>      mov       rcx,1                         ; i = 1
   146 00000062 48BE-               <1>      mov       rsi,array                     ; point to start of the array      
   146 00000064 [0000000000000000]  <1>
   147                              <1> .for:
   148 0000006C 48AD                <1>      lodsq                                   ; RBX = array[i]
   149 0000006E 4889C3              <1>      mov       rbx, rax
   150 00000071 48AD                <1>      lodsq                                   ; RAX = array[i+1]
   151 00000073 4839D8              <1>      cmp       rax, rbx                      ; if array[i+1] >= array[i]
   152 00000076 7D17                <1>      jge       .next
   153 00000078 4831D8              <1>      xor       rax, rbx                      ; then swap both values           
   154 0000007B 4831C3              <1>      xor       rbx, rax
   155 0000007E 4831D8              <1>      xor       rax, rbx
   156 00000081 4989CB              <1>      mov       r11, rcx                      ; newn = i    ADDED
   157 00000084 48895EF0            <1>      mov       qword [rsi-datasize*2], rbx   ; and store swapped values in array
   158 00000088 488946F8            <1>      mov       qword [rsi-datasize], rax
   159 0000008C 49FFC1              <1>      inc       r9                            ; increment number of swaps
   160                              <1> .next:
   161 0000008F 49FFC0              <1>      inc       r8                            ; increment number of iterations
   162 00000092 4883EE08            <1>      sub       rsi,datasize                  ; adjust pointer in array
   163 00000096 48FFC1              <1>      inc       rcx                           ; i++
   164 00000099 4C39D1              <1>      cmp       rcx, r10                      ; if i <= arrayLength-1
   165 0000009C 7ECE                <1>      jle       .for
   166 0000009E 4D89DA              <1>      mov       r10, r11                      ; n = newn   ADDED
   167                              <1> .until:
   168 000000A1 49FFCA              <1>      dec       r10
   169 000000A4 4983FA00            <1>      cmp       r10, 0                        ; if r10 > 0
   170 000000A8 7FAD                <1>      jg        .repeat                       ; then repeat sort algorithm
   126                                  %endif
   127                                  
   128                                  ; End of the BubbleSort algorithm.
   129                                  
   130                                  ; all we need to do is to display the sorted Array and restore the used registers
   131 000000AA 48BE-                       mov       rsi, sorted
   131 000000AC [6701000000000000] 
   132 000000B4 BA25000000                  mov       rdx, sorted.length
   133 000000B9 E846010000                  call      Print.string
   134 000000BE E860000000                  call      ShowArray
   135                                      ; show number of iterations
   136 000000C3 48BE-                       mov       rsi, iterations
   136 000000C5 [8C01000000000000] 
   137 000000CD BA17000000                  mov       rdx, iterations.length
   138 000000D2 E82D010000                  call      Print.string
   139 000000D7 4C89C0                      mov       rax, r8                       ; iterations in RAX
   140 000000DA E86B000000                  call      Convert                       ; RAX contains the number to convert
   141 000000DF E8F3000000                  call      Print.integer
   142 000000E4 E8D1000000                  call      ClearBuffer                   ; clear buffer for next use
   143                                       ; show number of swaps
   144 000000E9 4C89C8                      mov       rax, r9                       ; number of swaps in RAX
   145 000000EC 48BE-                       mov       rsi, swaps
   145 000000EE [A301000000000000] 
   146 000000F6 BA16000000                  mov       rdx, swaps.length
   147 000000FB E804010000                  call      Print.string
   148 00000100 E845000000                  call      Convert                       ; RAX contains the number to convert
   149 00000105 E8CD000000                  call      Print.integer
   150 0000010A E8E6000000                  call      Print.linefeed
   151                                       ; restore used registers
   152 0000010F 4158                        pop       r8
   153 00000111 4159                        pop       r9
   154 00000113 5E                          pop       rsi
   155 00000114 5A                          pop       rdx
   156 00000115 59                          pop       rcx
   157 00000116 5B                          pop       rbx
   158 00000117 58                          pop       rax
   159 00000118 9D                          popfq
   160                                  Exit:      
   161 00000119 4831FFB83C0000000F-         syscall   exit, 0
   161 00000122 05                 
   162                                  ShowArray:
   163 00000123 51                          push      rcx
   164 00000124 56                          push      rsi
   165 00000125 B91E000000                  mov       rcx, array.length             ; show all integers
   166 0000012A 48BE-                       mov       rsi, array                    ; start of the array
   166 0000012C [0000000000000000] 
   167                                  .nextInteger:      
   168 00000134 48AD                        lodsq                                   ; get integer
   169 00000136 E80F000000                  call      Convert                       ; RAX contains the number to convert
   170 0000013B E897000000                  call      Print.integer
   171 00000140 E875000000                  call      ClearBuffer                   ; clear buffer for next use
   172 00000145 E2ED                        loop      .nextInteger
   173 00000147 5E                          pop       rsi
   174 00000148 59                          pop       rcx
   175 00000149 C3                          ret
   176                                  Convert:
   177 0000014A 50                          push      rax
   178 0000014B 53                          push      rbx
   179 0000014C 52                          push      rdx
   180 0000014D 57                          push      rdi
   181 0000014E 51                          push      rcx
   182 0000014F 48BF-                       mov       rdi,sign
   182 00000151 [0000000000000000] 
   183 00000159 C60720                      mov       byte[rdi]," "                 ; default no sign
   184 0000015C 4883F800                    cmp       rax, 0
   185 00000160 7D06                        jge       .noSign
   186 00000162 C6072D                      mov       byte[rdi],"-"                 ; number is zero
   187 00000165 48F7D8                      neg       rax                           ; make positive
   188                                  .noSign:
   189 00000168 48BF-                       mov       rdi, decimal                  ; address of buffer in RDI 
   189 0000016A [0100000000000000] 
   190 00000172 4883C712                    add       rdi, 18                       ; 0..18 = 19 bytes of storage
   191                                      ; start conversion of absolute value of RAX
   192                                  .repeat:      
   193 00000176 4831D2                      xor       rdx, rdx                      ; remainder will be in RDX
   194 00000179 BB0A000000                  mov       rbx, 10
   195 0000017E 48F7F3                      div       rbx                           ; RDX = remainder of division
   196 00000181 80CA30                      or        dl,"0"                        ; make remainder decimal ASCII
   197 00000184 8817                        mov       byte[rdi],dl                  ; and store
   198 00000186 48FFCF                      dec       rdi                           ; go to previous position
   199 00000189 4883F800                    cmp       rax, 0                        ; RAX = quotient of division, if zero stop
   200                                                                              ; we can stop when AL < 10 however this will add more code to store AL
   201 0000018D 75E7                        jnz       .repeat
   202                                      ; align integers to the right
   203 0000018F 8A1425[00000000]            mov       dl ,byte[sign]                ; copy sign character in [RDI] just before the number
   204 00000196 8817                        mov       byte[rdi], dl
   205 00000198 48FFCF                      dec       rdi                           ; point to position before the sign character
   206 0000019B 4889F9                      mov       rcx, rdi                      ; calculate remaining bytes
   207 0000019E 4881E9[00000000]            sub       rcx, sign
   208 000001A5 4883F900                    cmp       rcx, 0
   209 000001A9 7E09                        jle       .end
   210 000001AB 48FFC1                      inc       rcx
   211 000001AE B020                        mov       al," "                        ; fill remaining bytes with spaces
   212 000001B0 FD                          std
   213                                  .fill:      
   214 000001B1 AA                          stosb
   215 000001B2 E2FD                        loop      .fill
   216                                  .end:      
   217 000001B4 59                          pop       rcx
   218 000001B5 5F                          pop       rdi
   219 000001B6 5A                          pop       rdx
   220 000001B7 5B                          pop       rbx
   221 000001B8 58                          pop       rax
   222 000001B9 C3                          ret
   223                                       
   224                                  ; **** Clear the integer buffer
   225                                  ClearBuffer:
   226 000001BA 50                          push      rax
   227 000001BB 51                          push      rcx
   228 000001BC 57                          push      rdi
   229 000001BD 48BF-                       mov       rdi, Buffer
   229 000001BF [0000000000000000] 
   230 000001C7 B914000000                  mov       rcx, 20                       ; 20 bytes to clear (1 added to clear last too)
   231 000001CC 4831C0                      xor       rax, rax
   232 000001CF FC                          cld                                     ; begin at lowest address
   233                                  .repeat:      
   234 000001D0 AA                          stosb                                   ; erase [RDI] and increment RSI pointer
   235 000001D1 E2FD                        loop      .repeat
   236 000001D3 5F                          pop       rdi
   237 000001D4 59                          pop       rcx
   238 000001D5 58                          pop       rax
   239 000001D6 C3                          ret
   240                                  ; *** Print routines
   241                                  Print:
   242                                  .integer:
   243 000001D7 52                          push      rdx
   244 000001D8 56                          push      rsi
   245 000001D9 48BE-                       mov       rsi,Buffer
   245 000001DB [0000000000000000] 
   246 000001E3 BA14000000                  mov       rdx, 20                       ; 20 bytes to display
   247 000001E8 E817000000                  call      Print.string
   248 000001ED E803000000                  call      Print.linefeed
   249 000001F2 5E                          pop       rsi
   250 000001F3 5A                          pop       rdx
   251 000001F4 C3                          ret
   252                                  .linefeed:
   253 000001F5 48BE-                       mov       rsi, lf
   253 000001F7 [B901000000000000] 
   254 000001FF BA01000000                  mov       rdx, lf.length
   255                                  .string:  
   256 00000204 50                          push      rax
   257 00000205 57                          push      rdi
   258 00000206 51                          push      rcx                           ; even not used, RCX is changed after syscall
   259 00000207 BF01000000B8010000-         syscall   write, stdout
   259 00000210 000F05             
   260 00000213 59                          pop       rcx
   261 00000214 5F                          pop       rdi
   262 00000215 58                          pop       rax
   263 00000216 C3                          ret
