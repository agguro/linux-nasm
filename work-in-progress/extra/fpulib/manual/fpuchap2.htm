<HTML>
<HEAD>
<META NAME="Author" CONTENT="Raymond Filiatreault">
<META NAME="Description" CONTENT="Tutorial on the use of the floating point coprocessor in assembly programming. Chap. 2 Data types used by the FPU and addressing modes">
<TITLE>Simply FPU Chap. 2</TITLE>
</HEAD>
<BODY TEXT="#402000" LINK="#0000ff" VLINK="#0000ff" ALINK="#0000ff" BACKGROUND="fpufigs/bluewave.gif">

<CENTER><FONT SIZE="+3">SIMPLY  FPU</FONT>
<BR>by <B>Raymond Filiatreault</B><BR>
Copyright 2003</CENTER>
<P>
<CENTER><B>Chap. 2<BR>
Data types used by the FPU and addressing modes</B></CENTER>

<P>	<FONT SIZE="-1"><EM>(Reminder: Addressing mode syntax in this document is that of the MASM assembler. The syntax may vary with other assemblers/compilers for the described addressing modes and should be modified as required.)</EM></FONT><BR>

<P>There are three general data types which can be used by the FPU: <A HREF="#ints">integer</A>, <A HREF="#floats">floating point</A> and <A HREF="#bcds">packed BCD</A>.

<BR>
<P><B><A NAME="ints">INTEGER DATA TYPES</A></B>

<P>In the context of FPU operations, integers are whole numbers, i.e. numbers which do not contain any fractional part. All integers used in FPU instructions are also considered as <U>signed</U> integers, the most significant bit being 0 for positive values or 1 for negative values.

<P>Negative integer values are represented by taking the 2's complement of the positive value and adding 1 (2's complements are obtained simply by inverting each bit of the number). As a refresher, the following example would be for a decimal value of 6235 in a 16-bit WORD.

<P><pre>
      0001 1000 0101 1011   185Bh   +6235d
      1110 0111 1010 0100   2's complement
     +                  1
      -------------------
      1110 0111 1010 0101   E7A5h   -6235d</pre>

<P>Within the integer data types, three sizes of integers may be used: the 16-bit <B>WORD</B>, the 32-bit <B>DWORD</B>, and the 64-bit <B>QWORD</B>, (the 8-bit byte cannot be used with FPU instructions). The available range of values for each of those sizes is as follows:

<P><pre>WORD range    &plusmn;(2<SUP><FONT SIZE="-1">15</FONT></SUP>-1)  or  &plusmn;32767
DWORD range   &plusmn;(2<SUP><FONT SIZE="-1">31</FONT></SUP>-1)  or  &plusmn;2147483647
QWORD range   &plusmn;(2<SUP><FONT SIZE="-1">63</FONT></SUP>-1)  or  &plusmn;9223372036854775807</pre>

<BR>
<P><B><A NAME="intmode"></A>Addressing modes of integer numbers</B>

<P>All integer data used with FPU instructions can only be accessed through memory locations. The actual code generated by the assembler is different for each of the allowed integer sizes.

<P>Integer values in memory can be specified by any of the acceptable addressing modes. For example, if a memory variable (global or local) has been declared as a WORD, the variable's name (whether it is indexed or not) is sufficient to get it treated as the declared size. However, if CPU registers are used as pointers to data in memory, it is imperative that the index be qualified as pointing to the appropriate size. Examples of referring to memory data are:

<P><B>var_name</B> ;the value of <EM>var_name</EM> being treated according to how that variable had been declared as a WORD, DWORD or QWORD

<P><B>var_name[24]</B> ;value starting at the 24<SUP>th</SUP> byte of the <EM>var_name</EM> variable according to how it had been declared

<P><B>var_name[ebx]</B> ;value starting at the EBX displacement in bytes of the <EM>var_name</EM> variable according to the above

<P><B>word ptr [eax]</B> ;informs the processor that EAX points to a 16-bit value

<P><B>dword ptr [esi+12]</B> ;ESI points to an array of 32-bit values

<P><B>qword ptr [edi+ebx]</B> ;EDI or EBX points to an array of 64-bit values

<P><B>dword ptr [ebp+8]</B> ;typical coding for pushed parameters of procedures when coded by the assembler

<P>The CPU registers cannot be used directly as the source or destination of integer data related to the FPU (as opposed to using them as pointers to the location of data in memory). If the need should arise to use the actual value in one of the CPU registers as the operand for data  in an FPU instruction, the following is suggested (the 16-bit signed value in AX being used for this example):

<BR><pre>
  <B>push  ax</B>              ;copies the value in AX to the stack or
                        ;prepares the stack for storing a value
  <B>fixxx word ptr [esp]</B>  ;fixxx being one of the FPU instructions
                        ;operating on integer data
  <B>pop ax</B>                ;restores the stack or
                        ;retrieves in AX the integer value stored by the FPU</pre>

<P><FONT SIZE="-1"><EM>For numerous reasons, the popped CPU register in the above example could be different from the one which was pushed. Several other CPU and/or FPU instructions could also be inserted between the push/pop instructions. And, an <A HREF="fpuchap3.htm#fwait">FWAIT</A> instruction may need to precede the pop instruction if its purpose is to retrieve a value stored by the FPU.</EM></FONT>

<P>Code similar to the above could be used for DWORD values in 32-bit registers.
<P> For QWORD values, such as obtained from a signed multiplication with the result in the EDX/EAX register pair, the sequence would need to be:
<pre><B>    push edx
    push eax
    fild qword ptr [esp]
    pop eax
    pop edx</B></pre>

<P><BR><B><A NAME="floats">FLOATING POINT DATA TYPES</A></B>

<P>The floating point data types are simply binary numbers represented in a manner similar to the scientific notation used for decimal values. For example:

<P>211 = 2.11 x 10<SUP><FONT SIZE="-1">2</FONT></SUP> (2.11E+0002)

<P>(The latter is the conventional syntax for decimal values in scientific notation when superscripts are not allowed in a text. For instance, most assemblers/compilers would not recognize superscripts.)

<P>If the above is divided by a multiple of 10 such as 100000, the only thing which would change in the scientific notation would be the exponent:

<P>211 ÷ 100000 = 0.00211 = 2.11 x 10<SUP><FONT SIZE="-1">-3</FONT></SUP> (2.11E-0003)

<P>In binary, the 211 value could be expressed as:

<P>11010011 = 1.1010011 x 2<SUP><FONT SIZE="-1">7</FONT></SUP> 

<P>In this case, if the above is divided by a multiple of 2 (such as 8), again the only thing which would change in the "binary scientific notation" would be the exponent:

<P>11010011 ÷ 2<SUP><FONT SIZE="-1">3</FONT></SUP> = 1.1010011 x 2<SUP><FONT SIZE="-1">4</FONT></SUP>

<P>As can be deduced, this allows for the representation of binary fractions, and of very large or very small values. The formatting of this "binary scientific notation" was standardized for the original CPUs and is usually called the IEEE (Institute of Electrical and Electronics Engineers) real number format.

<P>This real number format consists basically in dividing a binary numerical data into three fields: a sign field, an exponent field, and a number description (<U><B>significand</B></U>) field. The exponent field is biased to the middle of the available range such that negative exponents are effectively smaller than positive exponents. And, as opposed to the negative integer system of 2's complements, the significand field is always that of the positive number, negative numbers being distinguished strictly by the sign field.

<BR WP="BR1"><BR WP="BR2">
<P>Within the floating point data types, three sizes of real numbers are available:

<P>the 32-bit <B><A HREF="#real4">REAL4</A></B> (also called short real or single precision),
<BR>the 64-bit <B><A HREF="#real8">REAL8</A></B> (also called long real or double precision),
<BR>the 80-bit <B><A HREF="#real10">REAL10</A></B> (also called temporary real or extended precision).

<P><BR>The <B><A NAME="real4">REAL4</A></B> floating point number has the following format.

<P><img src="fpufigs/real4.gif" width="202" height="76">

<BR>where:

<BR>S = sign bit (0=positive, 1=negative)

<BR>E<EM>n</EM> = biased exponent bits

<BR>f<EM>n</EM> = fraction bits of the significand

<P>For REAL4 numbers, the bias of the 8 exponent's bits is 7Fh (the last 7 bits). This means that if the real exponent is 0, the value of the exponent field would be 7Fh. When the exponent is negative (i.e. for absolute values lower than 1), the value in the exponent field would be lower than 7Fh, and vice versa for values of 2 and higher.

<P>The maximum value of FFh in the exponent field is reserved for a special category of numbers designated as <A HREF="#nans">NAN</A> (Not-A-Number). This category includes the special value of <A HREF="#infini">INFINITY</A> and will be described later in more details.

<P>The value of 0 in the exponent field is also reserved for a special category of numbers. When all bits in the significand field are also 0, the value of the REAL number would be equal to 0. If any of the bits in the significand field are set, the value is then called a "<A HREF="#denormal">denormalized</A>" REAL number. This will also be described later in more details.

<P>Because a valid number in real format must always start with a 1, that first bit is implied in the REAL4 format and the significand field only contains the fraction bits f1, f2, etc. A value of +1.0 would thus be represented in REAL4 format as:
<pre>0 01111111 00000000000000000000000b (or 3F800000h in hex notation)</pre>

<FONT SIZE="-1"><EM>(Spaces are left in the binary representation to delineate the 3 fields.</EM></FONT>

<P>The value of +2.0 (1.0 x 2<SUP><FONT SIZE="-1">1</FONT></SUP>) would be:

<pre>0 10000000 00000000000000000000000b (or 40000000h in hex notation)
S   7Fh+1    fraction bits</pre>

<P>And the value of -2.0 would be:

<pre>1 10000000 00000000000000000000000b (or C0000000h in hex notation)</pre>

<P>The result of dividing -211 by 8 would give -1.1010011 x 2<SUP><FONT SIZE="-1">4</FONT></SUP> in binary scientific format and its REAL4 representation would be:

<pre>1 10000011 10100110000000000000000 (or C1D30000h in hex notation)
<P>S   7Fh+4    fraction bits</pre>

<P>As with all other numerical data, all REAL numbers are stored in memory with the least significant bytes first. The value of +1.0 in REAL4 format would thus appear in consecutive bytes of memory as:

<P>00 00 80 3F

<BR>
<P>The largest number which can be represented properly within the REAL4 format is when the exponent field contains FEh and the significand is almost equal to 2 (or almost 2<SUP><FONT SIZE="-1">80h</FONT></SUP> =2<SUP><FONT SIZE="-1">128d</FONT></SUP> or approx. 3.40x10<SUP><FONT SIZE="-1">38</FONT></SUP>). The smallest one would be when the exponent field contains 1 and the significand contains all 0s (or 2<SUP><FONT SIZE="-1">-7Eh</FONT></SUP> =2<SUP><FONT SIZE="-1">-126d</FONT></SUP> or approx. 1.17x10<SUP><FONT SIZE="-1">-38</FONT></SUP>).

<P>The 24 bits describing the number (23 bits in the significand field + 1 implied bit) is approximately equivalent to 7 decimal digits.

<P><BR>The <B><A NAME="real8">REAL8</A></B> floating point number has the following format.

<P><img src="fpufigs/real8.gif" width="401" height="76">

<P>For REAL8 numbers, the bias of the 11 exponent's bits is 3FFh (the last 10 bits). The maximum value of 7FFh in the exponent field is reserved for <A HREF="#nans">NANs</A>, and the value of 0 in that field has the same purpose as described for the REAL4 format.

<P>As with the REAL4 format, the first bit of the number is implied and the significand field only contains the fraction bits f1, f2, etc. A value of +1.0 would thus be represented in REAL8 format as:

<pre>0 01111111111 0000000000000000000000000000000000000000000000000000b
(or 3FF0000000000000h in hex notation).</pre>

<P>The largest number which can be represented properly within the REAL8 format is when the exponent field contains 7FEh and the significand is almost equal to 2 (or almost 2<SUP><FONT SIZE="-1">400h</FONT></SUP> =2<SUP><FONT SIZE="-1">1024d</FONT></SUP> or approx. 1.79x10<SUP><FONT SIZE="-1">308</FONT></SUP>). The smallest one would be when the exponent field contains 1 and the significand contains all 0s (or 2<SUP><FONT SIZE="-1">-3FEh</FONT></SUP> =2<SUP><FONT SIZE="-1">-1022d</FONT></SUP> or approx. 2.22x10<SUP><FONT SIZE="-1">-308</FONT></SUP>).

<P>The 53 bits describing the number (52 bits in the significand field + 1 implied bit) is approximately equivalent to 15 decimal digits.

<P><BR>The <B><A NAME="real10">REAL10</A></B> floating point number has the following format. That is the format used by the FPU's 80-bit data registers. (Real numbers in this format can be stored in memory but must be present in one of the FPU data registers in order to use them with other FPU instructions.)

<P><img src="fpufigs/real10.gif" width="501" height="76">

<P>For REAL10 numbers, the bias of the 15 exponent's bits is 3FFFh (the last 14 bits). The maximum value of 7FFFh in the exponent field is reserved for <A HREF="#nans">NANs</A>, and the value of 0 in that field has the same purpose as described for the REAL4 format.

<P>As opposed to the REAL4 and REAL8 formats, the first bit of the number is explicitly included in the significand field and followed by the fraction bits f1, f2, etc. A value of +1.0 would thus be represented in REAL10 format as:

<pre>0 011111111111111 10000...........0b
(or 3FFF8000000000000000h in hex notation).</pre>

<P>The largest number which can be represented properly within the REAL10 format is when the exponent field contains 7FFEh and the significand is almost equal to 2 (or almost 2<SUP><FONT SIZE="-1">4000h</FONT></SUP> =2<SUP><FONT SIZE="-1">16384d</FONT></SUP> or approx. 1.19x10<SUP><FONT SIZE="-1">4932</FONT></SUP>). The smallest one having full 64-bit precision would be when the exponent field contains 1 and the significand's fraction bits contain a 1 in bit 63 followed by all 0s (or 2<SUP><FONT SIZE="-1">-3FFEh</FONT></SUP> =2<SUP><FONT SIZE="-1">-16382d</FONT></SUP> or approx. 3.36x10<SUP><FONT SIZE="-1">-4932</FONT></SUP>).</P>

<P>The 64 bits of the significand describing the number is approximately equivalent to 19 decimal digits.

<P><BR><A NAME="realmode"><B>Addressing modes of real numbers</B>

<P>Floating point values in memory can be declared as REAL4, REAL8 or REAL10, but can also be declared simply as DWORD, QWORD or TBYTE respectively. When the latter is used and the variable is initialized, it would be assembled as a floating point value if the initializing value is in the scientific decimal format or contains at least one integer digit, a decimal point and at least one decimal digit. <FONT SIZE="-1"><EM>(It would be assembled as an integer if no decimal point is present.)</EM></FONT>

<P>When a floating point memory variable has been declared as one of the above, the variable's name (whether it is indexed or not) is sufficient to get it treated as the declared size. Examples given for declared integer variables would also apply for floating point variables. Although integer variables can also have identical sizes, specific FPU instructions are provided for each data type; there could never be any confusion for the assembler.

<P><B><U><A NAME="rule3">Rule #3:</A></U> The proper instruction must be used with the proper data type</B>

<P>This same rule also applies when using indirect indexing for floating point values. When using CPU registers as pointers to floating point data in memory, it is imperative that the index be qualified as pointing to the appropriate size. Examples of using <U>pointers to floating point data</U> in memory when used with the proper FPU instructions are:

<P><B>dword ptr [eax]</B> ;informs the processor that EAX points to a REAL4 value

<P><B>dword ptr [esi+12]</B> ;ESI would point to an array of REAL4 values

<P><B>qword ptr [edi+ebx]</B> ;EDI or EBX points to an array of REAL8 values

<P><B>tbyte ptr [edx]</B> ;EDX points to a REAL10 value

<P><B>dword ptr [ebp+8]</B> ;typical coding for pushed  REAL4 parameters of procedures when coded by the assembler

<P>Floating point values in the FPU's data registers can also be accessed with numerous FPU instructions. Since those are always 80-bit values, there is obviously no need to specify their size. As indicated in the previous chapter, their addressing mode is simply:

<P><B>ST(0)</B>, <B>ST(1)</B>, ...., <B>ST(7)</B>

<P><BR><B><U><A NAME="nans">NANs (Not-A-Number)</A></U></B>

<P>Whenever all the bits are set to 1 in the exponent field of a real number format, the value is designated as a NAN. Two values in that category are generated by the FPU:<BR>INFINITY and INDEFINITE.

<P><BR><U><A NAME="infini">INFINITY</A></U></P>

<P>In addition to the exponent field bits being all set to 1, the value of INFINITY has the following special coding to differentiate it from other NANs:

<P><B>All fraction bits of the significand field are 0</B> (the explicit 1 in bit 63 remains set for
the REAL10 format). In addition,

<BR>when the sign bit is 0, that NAN is treated as +INFINITY

<BR>when the sign bit is 1, that NAN is treated as -INFINITY

<P>Such values of INFINITY are generated by the FPU when

<P>- attempting to divide a valid number by 0 (Zero divide exception detected)

<P>- the result of a computation exceeds the maximum value allowable (Overflow exception
detected)

<P>- instructed to store a value larger than the upper limit of the destination format (Overflow exception detected).

<P>This INFINITY value can be used as an operand in FPU instructions. Depending on the instruction, the result can vary and exceptions may or may not be detected.

<P><BR><U><A NAME="indefini">INDEFINITE</A></U></P>

<P>In addition to the exponent field bits being all set to 1, the value of INDEFINITE has the following special coding to differentiate it from other NANs:

<P><B>The 1st fraction bit of the significand field (f1) is set to 1,</B> all other fraction bits being 0 (the explicit 1 in bit 63 remains set for the REAL10 format), <B>and the sign bit is set</B>.

<P>Such a value of INDEFINITE is generated by the FPU whenever a reasonable result is impossible for the given instruction. An Invalid exception is detected in some cases. Examples are:

<P>- using the value of INDEFINITE as an operand

<P>- using an empty register as an operand

<P>- subtracting two values of INFINITY

<P>- extracting the square root of a negative number.

<P><BR><U><A NAME="othernans"></A>Other NANs</U></P>

<P>Apart from the INFINITY and INDEFINITE values which can be generated by the FPU, there is a very large number of other NANs with all the possible permutations of fraction bits and sign bit being set to 1 when all the bits in the exponent field are set to 1. For example, the short REAL4 format could have over 16 million of them (2<SUP><FONT SIZE="-1">24</FONT></SUP>-3 to be more exact).

<P>There are two general categories of other NANs, the QNANs (Quiet NAN) and the SNANs (Signaling NAN). The difference between the two is that the first fraction bit is 1 for the QNAN (such as for the special INDEFINITE NAN) and 0 for the SNAN (but with at least one other fraction bit set to 1).

<P>Although NANs could be used as valid operands with some of the FPU instructions, they are of no practical use for the average programmer.

<P><BR><B><U><A NAME="denormal">Denormalized REAL numbers</A></U></B>

<P>The lowest value of the exponent field in a real number format is 1 if the number is to be considered "normal". Any further reduction of that small number may cause the value in the exponent field to become 0.

<P>Although the exponent field cannot be lower than 0, some numbers smaller than the smallest normal one can still be expressed when the exponent field becomes 0. The FPU does this by shifting the fraction bits to the right (along with the implicit or explicit 1) with some loss of precision due to the loss of the right-most bits. Those numbers are then qualified as <B>denormalized</B>.

<P>This concept should be easier to visualize with an example using a REAL4 small number, the smallest one being 1x2<SUP><FONT SIZE="-1">-7Eh</FONT></SUP> for that format.

<P>The result of dividing the previously used decimal value of 211 by 2<SUP><FONT SIZE="-1">86h</FONT></SUP> would be:

<P>1.1010011 x 2<SUP><FONT SIZE="-1">7</FONT></SUP> ÷ 2<SUP><FONT SIZE="-1">86h</FONT></SUP> = 1.1010011 x 2<SUP><FONT SIZE="-1">-7Eh</FONT></SUP> which, in REAL4 format, would still be in the
"normal number" range:

<pre>0 00000001 10100110000000000000000 (or 00D30000h in hex notation).</pre>

Dividing the above by 2 would now yield the following denormalized number:

<pre>0 00000000 11010011000000000000000 (or 00698000h in hex notation).</pre>

Dividing it again by 2 would give:

<pre>0 00000000 01101001100000000000000 (or 0034C000h in hex notation).</pre>

By repeating such division, the result would eventually become:

<pre>0 00000000 00000000000000000000001 (or 00000001h in hex notation).</pre>

It should now have become obvious that denormalized numbers suffer a loss of
precision as they get smaller until they eventually reach a value of zero. Although these denormalized numbers can be used by the FPU with all its instructions, this potential loss of precision must be fully understood by the programmer. Using floating point maths is not by itself a guarantee of accuracy.

<P><EM>For maximum accuracy, intermediate results of computations should never be stored in the REAL4 or REAL8 formats unless there is absolute certainty that the "normal number" limits of those formats would not be exceeded.</EM>

<P><BR><B><A NAME="bcds">PACKED BCD DATA TYPE</A></B>

<P>The Packed BCD (Binary Coded Decimal) data type is considered by the FPU as a signed integer and has the following 80-bit special packed decimal format.

<P><img src="fpufigs/packed.gif" width="501" height="76">

<BR>where:

<BR>S = sign bit (0=positive, 1=negative)

<BR>d<EM>n</EM> = 4-bit decimal values, d0 being the least significant

<BR>(bits 72-78 are not used and ignored)

<P>For example, the decimal value 211 in this data type format would be:

<pre>00000000000000000211h in hex notation</pre>

The decimal value of -65536 (-2<SUP><FONT SIZE="-1">16</FONT></SUP>) in this data type format would be:

<pre>80000000000000065536h in hex notation</pre>

As with all other numerical data, the packed BCD format is stored in memory with the least significant bytes first. The consecutive memory bytes (<U>in hex notation</U>) of the above number would thus be:

<P>36 55 06 00 00 00 00 00 00 80

<P>As depicted, 18 decimal digits is the maximum which can be inserted in this format. The largest integer which could be represented in this format would thus be 18 consecutive 9 (or 10<SUP><FONT SIZE="-1">18</FONT></SUP>-1).</P>

<P><BR><B>Addressing modes of packed BCD numbers</B>

<P>Packed BCD variables in memory can be declared only as TBYTE. Such variable is rarely, if ever, initialized. Its purpose is usually to reserved a memory space to either convert decimal strings into a format which will be acceptable to the FPU, or to instruct the FPU where to store a number after converting it to this format.

<P>Only two FPU instructions can use this data format and are specific for only this format. It is therefore never necessary to specify this memory data size, whether it is addresses by the variable's name or by a pointer. Examples of referring to memory data with the packed BCD FPU instructions are:

<P><B>var_name</B> ;the variable <EM>var_name</EM> must have been declared as a TBYTE, otherwise the assembler issues an error

<P><B>var_name[30]</B> or <B>var_name[ebx]</B> ;same as above with displacement

<P><B>[edi]</B> ;this will use the 10 bytes starting at the address pointed to by the register

<P>All other legitimate modes of indirect addressing are also acceptable. When using pointers, the programmer is responsible for insuring that the 10 bytes of memory at that address are suitable for the purpose.

<P><BR><CENTER><A HREF="index.html"><B>RETURN TO<B><BR><FONT SIZE="+2">SIMPLY  FPU</FONT>
<BR><B>CONTENTS<B></A></CENTER><BR>
</BODY>
</HTML>
